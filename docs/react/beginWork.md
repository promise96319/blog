| 标签                | 使用                                         | ReactElement.$$typeof                                        | ReactElement的type                                           | fiber                                                        | update                                                       | completeWork                                                 |
| ------------------- | -------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 为 RootFiber 的时候 | 不存在                                       | 不存在                                                       | 不存在                                                       | tag: HostRootcontainerInfo: 为根节点容器                     | updateHostRootcloneUpdateQueue  => 复制一个updateQueueprocessUpdateQueue => 处理updateQueue => firstBaseUpdate/lastBaseUpdate/effects(记录有callback的update) => getStateFromUpdate => 根据update得出新的 statereconcileChildren |                                                              |
| div等普通标签       | <div></div>                                  | REACT_ELEMENT_TYPE标签创建的都为element...xxx。函数创建的$$typeof不同。 | div小写的时候为普通字符串。大写的时候 type 为变量变量又分为函数形式和对象形式 | tag: HostComponenttype: divelementType: divpendingProps: element.props （为jsx解析的props） | updateHostComponentchildren => pendingProps.children => reconcileChildren如果 ref 存在，flags \|= ref | 如果 stateNode 不存在创建真实节点，并将子节点全添加到该真实节点上。fiber.stateNode = instance如果 stateNode 存在updateHostComponent对比 props，并形成新的 属性数组，挂在updateQueue上面例如：['name', 'li', 'id': 333, style: { color: 'red' }] workInProgress.updateQueue= (updatePayload:any);updateQueue存在，标记为更新 Update |
| Fragment            | <Fragment></Fragment>                        | REACT_ELEMENT_TYPE                                           | REACT_FRAGMENT_TYPE                                          | tag: FRAGMENTtype: nullelementType: nullpendingProps: element.props.children(就这个位置特殊一些) | 直接使用 children 进行 reconcile                             |                                                              |
| Suspense            | <Suspense fallback={...}>children</Suspense> | REACT_ELEMENT_TYPE                                           | REACT_SUSPENSE_TYPE                                          | tag: SuspenseComponenttype: nullelementType: REACT_SUSPENSE_TYPEpendingProps: element.props | updateSuspenseComponent当 current 不存在时createFiberFromFragmentmountWorkInProgressOffscreenFiber wip.memoizedState = { dehydrated: null, retry: NoLane }primaryChildFragment.memoizedState = { baseLanes: renderLanescachePool: getSuspensedCachePool()}suspense 的处理等到 completedWork 的时候再回来看 | pop(suspenseStackCursor, fiber)todo                          |
| SuspenseList        |                                              | REACT_ELEMENT_TYPE                                           | REACT_SUSPENSE_LIST_TYPE                                     | tag: SuspenseListComponenttype: nullelementType: REACT_SUSPENSE_LIST_TYPEpendingProps: element.props |                                                              |                                                              |
| Offscreen           |                                              | REACT_ELEMENT_TYPE                                           | REACT_OFFSCREEN_TYPE                                         | tag: OffscreeenComponenttype: nullelementType: REACT_OFFSCREEN_TYPEpendingProps: {mode: visible 或者 hiddenchildren: primaryChildren 或者 fallbackChildren} |                                                              |                                                              |
| class 组件          |                                              | REACT_ELEMENT_TYPE                                           | 为函数形式（是变量）class xxx {}                             | tag: ClassComponenttype: class xxx {} （此处的type可能经过处理）elementType: class xxx {}pendingProps: element.props | updateClassComponent当 instance 不存在时，重新创建 instanceconstructClassInstancecontextType => readContext => 形成dependencies => context组件实例化，instance = new Ctor(props, context)adoptClassInstancefiber.stateNode = instance给实例添加 updater，即setState等函数instance._reactInternals = fibermountClassInstanceinstance 添加 props/state/context/refsapplyDerivedStateFromProps => 将返回的 state 进行合并componentWillMount （废弃）如果 componentDidiMount 被定义了，fiber.flags \|= LayoutStatic当 instance 或 current 可以复用。updateClassInstance主要是通过 updateQueue 对 state 进行处理，然后更新 props/state/context 这三个值，并且调用相应的生命周期，还会为未来会执行的生命周期打上标记。 | bubbleProperties                                             |
| function 组件       |                                              | REACT_ELEMENT_TYPE                                           | 为函数形式（是变量）function xxx () {}                       | tag: IndeterminateComponent (函数组件起初未确定具体类型，后续beginWork 的时候进一步确定到底是class组件还是函数组件)type:function xxx () {}（此处的type可能经过处理）elementType: function xxx () {}pendingProps: element.props | updateFunctionComponent (详见 hooks)prepareReadContext => 处理 context，判断是否有更新renderWithHooks => 处理 hooks，记录到 fiber 上fiber.memoizedState = hook 链表hook => { memoizedState, baseState, baseQueue, queue, next }初始化 queue，queue里存放updatedispatch的时候，添加 update，并决定是否需要 schedule(具体见hooks) | bubbleProperties                                             |
|                     |                                              |                                                              |                                                              |                                                              |                                                              |                                                              |
| context.Provider    | <Provider value={xxx}></Provider>            | REACT_ELEMENT_TYPE                                           | 为对象形式（是变量）$$typeof: REACT_PROVIDER_TYPE_context: context | tag: ContextProvidertype:  为 type 对象 (对象形式的type都是这样的)elementType: 为 type 对象 (对象形式的type都是这样的)pendingProps:  element.props | 将 context 存储起来pushProvider(workInProgress, context, newValue)对比前后的 value 是否一致，如果不一致，向下递归寻找使用了 context的组件，通知要更新：propagateContextChange使用 contextType:此时访问 dependencies看是否context相同，相同则创建一个 ForceUpdate的 更新 给 ClassComponent。如果不是 ClassComponent，则说明遇到了consumer 的 fiber。如果遇到了下一个提供一样的 context的 Provider，跳过进行reconcileChildren | 移出 valueCursorbubbleProperties                             |
| context.Consumer    | <Consumer>{ value => <div></div>}</Consumer> | REACT_ELEMENT_TYPE                                           | 为对象形式（是变量）$$typeof: REACT_CONTEXT_TYPE_currentValue: defaultValue_currentValue2: defaultValueProvider: nullConsumer: null | tag: ContextConsumertype:  为 type 对象 (对象形式的type都是这样的)elementType: 为 type 对象 (对象形式的type都是这样的)pendingProps:  element.props | 判断当前 fiber 是否有 dependencies => didReceiveUpdatereadContext => 建立 fiber的denpendencies并获取 newValue获取 children => 也就是render 函数newChildren=render(newValue) |                                                              |
| forwardRef          | forwardRef((props, ref) => {return xxxx})    | REACT_ELEMENT_TYPE                                           | $$typeof: REACT_FORWARD_REF_TYPErender: 传入的render函数     | tag: ForwardReftype:  为 type 对象 (对象形式的type都是这样的)elementType: 为 type 对象 (对象形式的type都是这样的)pendingProps:  element.props | updateForwardRefrenderWithHooks时加了第二个参数 refchildren=Component(props, secondArg) |                                                              |
| lazy                | lazy(() => import('./xxx'))                  | REACT_ELEMENT_TYPE                                           | $$typeof: REACT_LAZY_TYPE_payload: { _status: -1, _reuslt: ctor }_init: 包装 _payload 的函数 | tag: LazyComponenttype: null  （特殊情况，还没加载完，无法确定类型）elementType: 为 type 对象 (对象形式的type都是这样的)pendingProps:  element.props | updateLazyComponentComponent = _init(_payload) (第一次渲染的时候beginWork会throw出去 error,然后被suspense捕捉，捕捉后会进行 completeWork，随后继续进行 beiginWork + completeWork + commitRoot)Suspense fiber 上 flags 会新增 ShouldCapture type = Componenttag = 根据 Component 确定如果在渲染的时候它没有加载完成，那么他就会报错，然后会全局捕捉到这个错误，进行 throwExpection。找到对应的fiber，通过该 fiber 找到第一个 suspense，将 throw 出来的 promise 放到 suspense 的 updateQueue里面。并且 listen promsie => 执行 then 的时候进行 pingSuspendedRoot => ensureRootIsScheduled。达到重新渲染的目的。 |                                                              |
| memo                | memo(componet)                               | REACT_ELEMENT_TYPE                                           | $$typeof: REACT_MEMO_TYPEtype: 传入的构造函数                | tag: MemoComponenttype:  为 type 对象 (对象形式的type都是这样的)elementType: 为 type 对象 (对象形式的type都是这样的)pendingProps:  element.props | updateMemoComponentcurrent为null时和普通创建 fiber没大的区别如果current存在，判断被memo的节点是否有更新，没有更新就提前finish |                                                              |
|                     |                                              |                                                              |                                                              |                                                              |                                                              |                                                              |
| createPortal        | createPortal(children, container)            | REACT_ELEMENT_TYPE（但是portal在处理的时候通过函数返回，函数执行的时候返回children，reconciler的时候判别的是REACT_PORTAL_TYPE） | $$typeof: REACT_PORTAL_TYPEkey: keychildren: childrencontainerInfo: 容器container | tag: HostPortaltype: nullelementType: nullpendingProps: portal.children （也就是创建时的节点）stateNode: {  contianerInfo: portal.contianerInfo,pendingChildren: null...} | 推入 portal 的 containerInfo在首次创建 fiber 的时候也记录 更新、插入等过程。 | popHostContainerbubbleProperties                             |

