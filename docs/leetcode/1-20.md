# 1-20题

## 1.两数之和
[https://leetcode-cn.com/problems/two-sum/submissions/](https://leetcode-cn.com/problems/two-sum/submissions/)
::: tip 思路
建立一个 { 数字: index } 的对象，遍历数组，根据当前数算出省关于的数，通过建立的对象判断剩余的数对应的 index 是否存在。

时间复杂度O(n)，空间复杂度O(n)
:::

``` typescript
function twoSum(nums: number[], target: number): number[] {
    const map = {}
    for (let i = 0; i < nums.length; i++) {
        const rest = target - nums[i]
        if (map[rest] || map[rest] === 0) {
            return [map[rest], i]
        }
        map[nums[i]] = i
    }
    return []
};
```

## 2.两数相加
[https://leetcode-cn.com/problems/add-two-numbers/submissions/](https://leetcode-cn.com/problems/add-two-numbers/submissions/)
::: tip 思路
1. 需要遍历两个链表，并将相加的结果放到新的链表中。
2. 需要一个变量标记相加结果是否会向前一位进1。
3. 注意在最高时存在节点消耗完，但是进1的情况。
:::

``` typescript
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

function addTwoNumbers(l1: ListNode | null, l2: ListNode | null): ListNode | null {
    let result: ListNode | null = null
    let node1 = l1
    let node2 = l2
    let cur = result
    // 是否需要加1
    let needAddOne = false
    while (node1 || node2 || needAddOne) {
        const sum = (node1 && node1.val) + (node2 && node2.val) + (needAddOne ? 1 : 0)
        needAddOne = sum >= 10
        if (cur === null) {
            result = cur = new ListNode(sum % 10)
        } else {
            cur = cur.next = new ListNode(sum % 10)
        }
        node1 = node1 && node1.next
        node2 = node2 && node2.next
    }

    return result
};
```

## 3. 最长不重复字符串
[https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/submissions/](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/submissions/)
::: tip 思路
遍历字符串，记录以当前字符串结尾的最长不重复字符串。如果遇到重复的情况，则找到哪一个字符重复，截取下来。
:::

``` typescript
function lengthOfLongestSubstring(s: string): number {
    let curStr = ''
    let max = 0
    for (let i = 0; i < s.length; i++) {
        // 判断内部是否存在，如果存在，说明重复了。
        let index = curStr.indexOf(s[i])
        if (index !== -1) {
            // 不符合要求，找到对应的 index，删除前面的string
            curStr = curStr.slice(index + 1) + s[i]
        } else {
            // 符合要求
            curStr += s[i]
        }
        max = Math.max(curStr.length, max)
    }
    return max
};
```