import{_ as e,o,c as t,Q as d}from"./chunks/framework.c610f10c.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"project/semi-design.md","filePath":"project/semi-design.md","lastUpdated":1695631559000}'),a={name:"project/semi-design.md"},c=d('<p>Semi Design</p><p><a href="https://bytedance.feishu.cn/wiki/wikcnOVYexosCS1Rmvb5qCsWT1f" target="_blank" rel="noreferrer">Semi Design - UI组件库如何分层设计，使其具备适配多种mvvm框架能力</a></p><h3 id="问题" tabindex="-1">问题 <a class="header-anchor" href="#问题" aria-label="Permalink to &quot;问题&quot;">​</a></h3><p>不同的框架需要封装不同的组件，比如 <code>antd(react)</code> 需要使用到 <code>react</code> 版的 <code>rc-table</code>，如果需要在 vue 使用 <code>antd</code> ，那么需要重新写 <code>vue</code> 版的 <code>antd</code>，同时还需要写 <code>vue</code> 版的 <code>rc-table</code>。如果还需要放到 svelte 版本，那么所有基础组件内容都得重写一遍。</p><h3 id="解决" tabindex="-1">解决 <a class="header-anchor" href="#解决" aria-label="Permalink to &quot;解决&quot;">​</a></h3><p><code>semi design</code> 通过 <code>Foundation/Adapter</code> 实现了组件逻辑上的复用，而不限于框架层面。其实就是适配器模式。</p><p>对于一个组件来讲，不同的框架，他们不同的地方主要在DOM结构的编写、状态的定义与修改上，其他内容都是共用的。</p><p>比如 <code>handleChange</code> 后的逻辑，对于不同的框架来讲都是共通的，不同的是最后触发更新 <code>state</code> 的方式不同。</p><p>因此，<code>F/A</code> 架构将这些共同的内容，也就是组件的逻辑封装到 <code>Foundation</code> 组件中，而不同的地方通过 <code>Adapter</code> 适配器的方式对状态，事件处理，<code>dom</code> 结构进行兼容处理。</p><p><strong>最后组件封装变为</strong>： <code>data/state =&gt; onClick =&gt; foundation.handleClick =&gt; foundation 处理逻辑 =&gt; foundation 调用 adapter 变更状态 =&gt; adpter 通过 setState/this.data 更改状态</code>。</p><p>因此，对于不同框架版本的组件，最终只需要做不同版本的 <code>adapter</code> 即可。而组件内部的计算逻辑都能轻易复用。</p>',11),n=[c];function r(s,i,p,_,l,h){return o(),t("div",null,n)}const f=e(a,[["render",r]]);export{u as __pageData,f as default};
