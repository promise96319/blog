import{_ as e,c as l,o as i,a as r}from"./app.026f8370.js";const m=JSON.parse('{"title":"Rollup","description":"","frontmatter":{},"headers":[{"level":2,"title":"知识点","slug":"知识点","link":"#知识点","children":[]},{"level":2,"title":"Graph","slug":"graph","link":"#graph","children":[{"level":3,"title":"build","slug":"build","link":"#build","children":[]},{"level":3,"title":"工具方法","slug":"工具方法","link":"#工具方法","children":[]}]},{"level":2,"title":"ModuleLoader","slug":"moduleloader","link":"#moduleloader","children":[]},{"level":2,"title":"Module","slug":"module","link":"#module","children":[]},{"level":2,"title":"Bundle","slug":"bundle","link":"#bundle","children":[{"level":3,"title":"generate","slug":"generate","link":"#generate","children":[]}]},{"level":2,"title":"Chunk","slug":"chunk","link":"#chunk","children":[]},{"level":2,"title":"rollup","slug":"rollup-1","link":"#rollup-1","children":[]},{"level":2,"title":"PluginDriver","slug":"plugindriver","link":"#plugindriver","children":[]},{"level":2,"title":"FileEmitter","slug":"fileemitter","link":"#fileemitter","children":[]},{"level":2,"title":"文章","slug":"文章","link":"#文章","children":[]}],"relativePath":"rollup/index.md","lastUpdated":1679906492000}'),a={name:"rollup/index.md"},t=r(`<h1 id="rollup" tabindex="-1">Rollup <a class="header-anchor" href="#rollup" aria-hidden="true">#</a></h1><ul><li><a href="./源码调试">源码调试</a></li></ul><h2 id="知识点" tabindex="-1">知识点 <a class="header-anchor" href="#知识点" aria-hidden="true">#</a></h2><ul><li>Queue 的实现，最大并发执行 promise，并且有返回值等。</li><li>Promise 串行</li><li>循环依赖时警告⚠️</li></ul><h2 id="graph" tabindex="-1">Graph <a class="header-anchor" href="#graph" aria-hidden="true">#</a></h2><h3 id="build" tabindex="-1">build <a class="header-anchor" href="#build" aria-hidden="true">#</a></h3><ul><li>generateModuleGraph <ul><li>moduleLoader.addEntryModules =&gt; modules 和 externalModules</li></ul></li><li>sortModules <ul><li>circlePaths =&gt; 会使用深度遍历的方式判断是否存在循环依赖，并且提示警告。</li><li>ast.bind() =&gt; ast 中变量作用域 ?</li></ul></li><li>includeStatements <ul><li>tree shaking ?</li><li>module <ul><li>implicitly: export * form &#39;./foo.js&#39; <ul><li><a href="https://stackoverflow.com/questions/56277089/how-does-one-implicitly-export-an-entire-module" target="_blank" rel="noreferrer">https://stackoverflow.com/questions/56277089/how-does-one-implicitly-export-an-entire-module</a></li></ul></li><li>explicitly: export { foo } form &#39;./foo.js&#39;</li></ul></li></ul></li></ul><h3 id="工具方法" tabindex="-1">工具方法 <a class="header-anchor" href="#工具方法" aria-hidden="true">#</a></h3><pre><code>- pluginDriver
- moduleLoader
- acornParser
- fileOperationQueue
- getModuleInfo （获取模块信息）
</code></pre><h2 id="moduleloader" tabindex="-1">ModuleLoader <a class="header-anchor" href="#moduleloader" aria-hidden="true">#</a></h2><ul><li>addEntryModules =&gt; loadEntryModule =&gt; resolveId =&gt; fetchModule =&gt; new Module =&gt; addModuleSource =&gt; fs.readFile =&gt; transform（插件转换）=&gt; module.setSource（ast 解析）=&gt; 获取静态和动态 dependencies，并关联父子关系 =&gt; moduleParsed hook =&gt; fetchModuleDependencies 加载子模块</li></ul><h2 id="module" tabindex="-1">Module <a class="header-anchor" href="#module" aria-hidden="true">#</a></h2><ul><li>astContext：提供 ast 上下文</li><li>bindReferences： ast.bind()</li><li>include：ast.include()</li><li>setSource：解析成 ast，</li><li>sources：当前模块中使用到的其他模块的路径 <ul><li>import * from &#39;index.js&#39; =&gt; 存的是 index.js</li></ul></li></ul><h2 id="bundle" tabindex="-1">Bundle <a class="header-anchor" href="#bundle" aria-hidden="true">#</a></h2><h3 id="generate" tabindex="-1">generate <a class="header-anchor" href="#generate" aria-hidden="true">#</a></h3><ul><li>setOutputBundle ?</li><li>generateChunk <ul><li>getChunkAssignments =&gt; 生成 [{ alias, modules }] 即 chunk 数组和每一个 chunk 对应的 module</li><li>new Chunk() =&gt; chunk =&gt; chunks</li><li>chunk.link() =&gt; 关联 module/dependency 和 chunk 关系</li><li>generateFacades （根据 preserveentrysignatures 来定）</li></ul></li></ul><h2 id="chunk" tabindex="-1">Chunk <a class="header-anchor" href="#chunk" aria-hidden="true">#</a></h2><ul><li></li></ul><h2 id="rollup-1" tabindex="-1">rollup <a class="header-anchor" href="#rollup-1" aria-hidden="true">#</a></h2><ul><li>graph.build()</li><li>graph.handleGenerateWrite() <ul><li>getOutputOptionsAndPluginDriver =&gt; 生成 outputPluginDriver</li><li>new Bundle() =&gt; generate <ul><li>setOutputBundle =&gt; 给 fileEmitter 的处理</li><li></li></ul></li><li>graph.fileOperationQueue =&gt; writefile</li><li>对 generate 内容整理后返回（供命令式调用）</li></ul></li></ul><h2 id="plugindriver" tabindex="-1">PluginDriver <a class="header-anchor" href="#plugindriver" aria-hidden="true">#</a></h2><ul><li>build 阶段为 inputPluginDriver</li><li>bundle 阶段为 outputPluginDriver，感觉这块代码职责不是很清晰</li></ul><h2 id="fileemitter" tabindex="-1">FileEmitter <a class="header-anchor" href="#fileemitter" aria-hidden="true">#</a></h2><ul><li>管理 chunk（对应多个模块） 和 asset（对应单一个模块）</li><li></li></ul><h2 id="文章" tabindex="-1">文章 <a class="header-anchor" href="#文章" aria-hidden="true">#</a></h2><ul><li><a href="https://medium.com/@PepsRyuu/why-i-use-rollup-and-not-webpack-e3ab163f4fd3" target="_blank" rel="noreferrer">https://medium.com/@PepsRyuu/why-i-use-rollup-and-not-webpack-e3ab163f4fd3</a><ul><li>webpack 配置多，复杂性高，打包后的代码臃肿。功能全面。</li><li>parcel 零配置，但是对于大型项目想要优化定制比较困难。</li><li>rollup 配置较少，hoist 打包后代码清晰。仅支持 esm，需要通过扩展来支持其他类型文件，生产环境兼容性不好。</li></ul></li></ul>`,26),u=[t];function d(n,o,h,s,c,p){return i(),l("div",null,u)}const f=e(a,[["render",d]]);export{m as __pageData,f as default};
