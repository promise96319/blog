import{_ as s,o as n,c as a,Q as l}from"./chunks/framework.92ce8a2a.js";const b=JSON.parse('{"title":"beginWork - fiber的创建","description":"","frontmatter":{},"headers":[],"relativePath":"react/beginWork-fiber创建.md","filePath":"react/beginWork-fiber创建.md","lastUpdated":1695640069000}'),p={name:"react/beginWork-fiber创建.md"},o=l(`<h1 id="beginwork-fiber的创建" tabindex="-1">beginWork - fiber的创建 <a class="header-anchor" href="#beginwork-fiber的创建" aria-label="Permalink to &quot;beginWork - fiber的创建&quot;">​</a></h1><h2 id="开始" tabindex="-1">开始 <a class="header-anchor" href="#开始" aria-label="Permalink to &quot;开始&quot;">​</a></h2><p>更新过程中，调度任务最终执行的小任务是<code>performUnitOfWork</code>：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">performUnitOfWork</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">unitOfWork</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Fiber</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">void</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">current</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> unitOfWork.alternate;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> next;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 为 children 创建 fiber</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 调用 reconcileChildren，建立了当前 unitOfWork 及其 children 的fiber联系</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 并且将 fiber 的 flags 进行了标记，用于替换、移除等操作</span></span>
<span class="line"><span style="color:#E1E4E8;">  next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">beginWork</span><span style="color:#E1E4E8;">(current, unitOfWork, subtreeRenderLanes);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  unitOfWork.memoizedProps </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> unitOfWork.pendingProps;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (next </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 如果没有 next child，那么开始 complete.</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 创建真实节点</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">completeUnitOfWork</span><span style="color:#E1E4E8;">(unitOfWork);</span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 如果存在 next,说明还有 child,继续向下递归 beginWork</span></span>
<span class="line"><span style="color:#E1E4E8;">    workInProgress </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> next;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">performUnitOfWork</span><span style="color:#24292E;">(</span><span style="color:#E36209;">unitOfWork</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Fiber</span><span style="color:#24292E;">)</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">void</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">current</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> unitOfWork.alternate;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> next;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 为 children 创建 fiber</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 调用 reconcileChildren，建立了当前 unitOfWork 及其 children 的fiber联系</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 并且将 fiber 的 flags 进行了标记，用于替换、移除等操作</span></span>
<span class="line"><span style="color:#24292E;">  next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">beginWork</span><span style="color:#24292E;">(current, unitOfWork, subtreeRenderLanes);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  unitOfWork.memoizedProps </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> unitOfWork.pendingProps;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (next </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如果没有 next child，那么开始 complete.</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 创建真实节点</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">completeUnitOfWork</span><span style="color:#24292E;">(unitOfWork);</span></span>
<span class="line"><span style="color:#24292E;">  } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如果存在 next,说明还有 child,继续向下递归 beginWork</span></span>
<span class="line"><span style="color:#24292E;">    workInProgress </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> next;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>总共分为两步，一是<code>beginWork</code>，二是<code>completeWork</code>。<code>beginWork</code>主要是向下”递“的过程，根据节点创建或复用<code>fiber</code>。<code>completeWork</code>是向上”归“的过程，由下至上根据<code>fiber</code>创建或复用真实节点。</p><h2 id="beginwork" tabindex="-1">beginWork <a class="header-anchor" href="#beginwork" aria-label="Permalink to &quot;beginWork&quot;">​</a></h2><p><code>beginWork</code>主要分为两部分组成，一部分为<code>reconcilerChildren</code>，主要的作用是为当前的<code>fiber</code>节点的子节点创建<code>fiber</code>，并且建立<code>fiber</code>之间的联系。第二部分是为不同类型的<code>fiber</code>节点更新不同的属性。<code>beginWork</code>的定义是在<code>react-reconciler/src/ReactFiberBeginWork.new.js</code>文件中。</p><h2 id="updatehostroot" tabindex="-1">updateHostRoot <a class="header-anchor" href="#updatehostroot" aria-label="Permalink to &quot;updateHostRoot&quot;">​</a></h2><p><code>HostRoot</code>的<code>fiber</code>在最开始就已经创建了，也就是之前提到的<code>RootFiber</code>。这里先从<code>updateHostRoot</code>方法开始：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nextProps</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> workInProgress.pendingProps;</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">prevState</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> workInProgress.memoizedState;</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">prevChildren</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> prevState.element;</span></span>
<span class="line"><span style="color:#B392F0;">cloneUpdateQueue</span><span style="color:#E1E4E8;">(current, workInProgress);</span></span>
<span class="line"><span style="color:#B392F0;">processUpdateQueue</span><span style="color:#E1E4E8;">(workInProgress, nextProps, </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">, renderLanes);</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nextState</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> workInProgress.memoizedState;</span></span>
<span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (nextChildren </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> prevChildren) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// children 没有变化，提前终止当前child对比，</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 如果有孙子节点变化，那么直接找到对应孙子节点进行处理</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">bailoutOnAlreadyFinishedWork</span><span style="color:#E1E4E8;">(current, workInProgress, renderLanes);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nextProps</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> workInProgress.pendingProps;</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">prevState</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> workInProgress.memoizedState;</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">prevChildren</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> prevState.element;</span></span>
<span class="line"><span style="color:#6F42C1;">cloneUpdateQueue</span><span style="color:#24292E;">(current, workInProgress);</span></span>
<span class="line"><span style="color:#6F42C1;">processUpdateQueue</span><span style="color:#24292E;">(workInProgress, nextProps, </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">, renderLanes);</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nextState</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> workInProgress.memoizedState;</span></span>
<span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (nextChildren </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> prevChildren) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// children 没有变化，提前终止当前child对比，</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 如果有孙子节点变化，那么直接找到对应孙子节点进行处理</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">bailoutOnAlreadyFinishedWork</span><span style="color:#24292E;">(current, workInProgress, renderLanes);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>首先执行<code>processUpdateQueue</code>方法，在<code>UpdateQueue</code>章节中已经提到，该方法主要是执行<code>updateQueue</code>返回一个新的<code>state</code>。如果前后的<code>state</code>一致，那么可以跳过后续的<code>reconcile</code>阶段。如果不一致，就需要执行<code>reconcileChildren</code>方法为子节点分别创建<code>fiber</code>了。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">reconcileChildren</span><span style="color:#E1E4E8;">(current, workInProgress, nextChildren, renderLanes);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">reconcileChildren</span><span style="color:#24292E;">(current, workInProgress, nextChildren, renderLanes);</span></span></code></pre></div><h2 id="reconcilechildren" tabindex="-1">reconcileChildren <a class="header-anchor" href="#reconcilechildren" aria-label="Permalink to &quot;reconcileChildren&quot;">​</a></h2><p><code>reconcileChildren</code>分为两种情况：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">export</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">reconcileChildren</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">current</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Fiber</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">, </span><span style="color:#6A737D;">// 老的 fiber</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">workInProgress</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Fiber</span><span style="color:#E1E4E8;">, </span><span style="color:#6A737D;">// 当前工作的 fiber，新fiber</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">nextChildren</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">any</span><span style="color:#E1E4E8;">, </span><span style="color:#6A737D;">// 新 fiber pendingProps 上的 children</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">renderLanes</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Lanes</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (current </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    workInProgress.child </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">mountChildFibers</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">      workInProgress,</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">      nextChildren,</span></span>
<span class="line"><span style="color:#E1E4E8;">      renderLanes,</span></span>
<span class="line"><span style="color:#E1E4E8;">    );</span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    workInProgress.child </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">reconcileChildFibers</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">      workInProgress,</span></span>
<span class="line"><span style="color:#E1E4E8;">      current.child,</span></span>
<span class="line"><span style="color:#E1E4E8;">      nextChildren,</span></span>
<span class="line"><span style="color:#E1E4E8;">      renderLanes,</span></span>
<span class="line"><span style="color:#E1E4E8;">    );</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">export</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">reconcileChildren</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">current</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Fiber</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">, </span><span style="color:#6A737D;">// 老的 fiber</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">workInProgress</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Fiber</span><span style="color:#24292E;">, </span><span style="color:#6A737D;">// 当前工作的 fiber，新fiber</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">nextChildren</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">any</span><span style="color:#24292E;">, </span><span style="color:#6A737D;">// 新 fiber pendingProps 上的 children</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">renderLanes</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Lanes</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (current </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    workInProgress.child </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">mountChildFibers</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">      workInProgress,</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">      nextChildren,</span></span>
<span class="line"><span style="color:#24292E;">      renderLanes,</span></span>
<span class="line"><span style="color:#24292E;">    );</span></span>
<span class="line"><span style="color:#24292E;">  } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    workInProgress.child </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">reconcileChildFibers</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">      workInProgress,</span></span>
<span class="line"><span style="color:#24292E;">      current.child,</span></span>
<span class="line"><span style="color:#24292E;">      nextChildren,</span></span>
<span class="line"><span style="color:#24292E;">      renderLanes,</span></span>
<span class="line"><span style="color:#24292E;">    );</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>一种是<code>current</code>存在，一种是<code>current</code>不存在，他们唯一的区别就是第二个参数不一致。找到<code>ReactChildFiber.new.js</code>文件：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">export</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">reconcileChildFibers</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ChildReconciler</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">export</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">mountChildFibers</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ChildReconciler</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">export</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">reconcileChildFibers</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ChildReconciler</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">true</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#D73A49;">export</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">mountChildFibers</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ChildReconciler</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">false</span><span style="color:#24292E;">);</span></span></code></pre></div><p>它们的区别就是第一个参数不同，实际上与<code>current</code>存不存在是具有一定关系的。这个参数尤为关键，它会影响到后续的<code>fiber.flags</code>的值。</p><h2 id="reconcilechildfibers" tabindex="-1">reconcileChildFibers <a class="header-anchor" href="#reconcilechildfibers" aria-label="Permalink to &quot;reconcileChildFibers&quot;">​</a></h2><p>我们先来看一下<code>reconcileChildFibers</code>方法，当<code>newChild</code>为<code>string/number</code>时比较简单，就是一个<code>text</code>节点。我们主要讨论为<code>object</code>的情况，其中<code>newChild.$$typeof</code>主要分为三种情况：</p><h3 id="react-portal-type" tabindex="-1">REACT_PORTAL_TYPE <a class="header-anchor" href="#react-portal-type" aria-label="Permalink to &quot;REACT_PORTAL_TYPE&quot;">​</a></h3><p>此节点是由<code>React.createPortal</code>方法创建:</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">export</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">createPortal</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">children</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ReactNodeList</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">containerInfo</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">any</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">implementation</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">any</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">key</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">?</span><span style="color:#79B8FF;">string</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ReactPortal</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    $$typeof: </span><span style="color:#79B8FF;">REACT_PORTAL_TYPE</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">    key: key </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;&#39;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> key,</span></span>
<span class="line"><span style="color:#E1E4E8;">    children,</span></span>
<span class="line"><span style="color:#E1E4E8;">    containerInfo,</span></span>
<span class="line"><span style="color:#E1E4E8;">    implementation,</span></span>
<span class="line"><span style="color:#E1E4E8;">  };</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">export</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">createPortal</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">children</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ReactNodeList</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">containerInfo</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">any</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">implementation</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">any</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">key</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">?</span><span style="color:#005CC5;">string</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">)</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ReactPortal</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    $$typeof: </span><span style="color:#005CC5;">REACT_PORTAL_TYPE</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">    key: key </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;&#39;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> key,</span></span>
<span class="line"><span style="color:#24292E;">    children,</span></span>
<span class="line"><span style="color:#24292E;">    containerInfo,</span></span>
<span class="line"><span style="color:#24292E;">    implementation,</span></span>
<span class="line"><span style="color:#24292E;">  };</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>此时<code>jsx</code>解析出来的<code>type</code>就是返回的<code>type</code>。而这个<code>type</code>里的<code>$$typeof</code>是<code>REACT_PORTAL_TYPE</code>。</p><h3 id="react-lazy-type" tabindex="-1">REACT_LAZY_TYPE <a class="header-anchor" href="#react-lazy-type" aria-label="Permalink to &quot;REACT_LAZY_TYPE&quot;">​</a></h3><p>此时调用的<code>React.lazy</code>方法创建的节点:</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">export</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">lazy</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;(</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">ctor</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Thenable</span><span style="color:#E1E4E8;">&lt;{</span><span style="color:#FFAB70;">default</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">...</span><span style="color:#E1E4E8;">}&gt;,</span></span>
<span class="line"><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">LazyComponent</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">, </span><span style="color:#B392F0;">Payload</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;&gt; {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">payload</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Payload</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    _status: </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">    _result: ctor,</span></span>
<span class="line"><span style="color:#E1E4E8;">  };</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">lazyType</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">LazyComponent</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">, </span><span style="color:#B392F0;">Payload</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;&gt; </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    $$typeof: </span><span style="color:#79B8FF;">REACT_LAZY_TYPE</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">    _payload: payload,</span></span>
<span class="line"><span style="color:#E1E4E8;">    _init: lazyInitializer,</span></span>
<span class="line"><span style="color:#E1E4E8;">  };</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> lazyType;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">export</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">lazy</span><span style="color:#24292E;">&lt;</span><span style="color:#6F42C1;">T</span><span style="color:#24292E;">&gt;(</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">ctor</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> () </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Thenable</span><span style="color:#24292E;">&lt;{</span><span style="color:#E36209;">default</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">T</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">...</span><span style="color:#24292E;">}&gt;,</span></span>
<span class="line"><span style="color:#24292E;">)</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">LazyComponent</span><span style="color:#24292E;">&lt;</span><span style="color:#6F42C1;">T</span><span style="color:#24292E;">, </span><span style="color:#6F42C1;">Payload</span><span style="color:#24292E;">&lt;</span><span style="color:#6F42C1;">T</span><span style="color:#24292E;">&gt;&gt; {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">payload</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Payload</span><span style="color:#24292E;">&lt;</span><span style="color:#6F42C1;">T</span><span style="color:#24292E;">&gt; </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    _status: </span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">    _result: ctor,</span></span>
<span class="line"><span style="color:#24292E;">  };</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">lazyType</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">LazyComponent</span><span style="color:#24292E;">&lt;</span><span style="color:#6F42C1;">T</span><span style="color:#24292E;">, </span><span style="color:#6F42C1;">Payload</span><span style="color:#24292E;">&lt;</span><span style="color:#6F42C1;">T</span><span style="color:#24292E;">&gt;&gt; </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    $$typeof: </span><span style="color:#005CC5;">REACT_LAZY_TYPE</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">    _payload: payload,</span></span>
<span class="line"><span style="color:#24292E;">    _init: lazyInitializer,</span></span>
<span class="line"><span style="color:#24292E;">  };</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> lazyType;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="react-element-type" tabindex="-1">REACT_ELEMENT_TYPE <a class="header-anchor" href="#react-element-type" aria-label="Permalink to &quot;REACT_ELEMENT_TYPE&quot;">​</a></h3><p>当<code>$$typeof</code>为<code>REACT_ELEMENT_TYPE</code>的时候，会调用<code>reconcileSingleElement</code>方法。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">placeSingleChild</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">reconcileSingleElement</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">    returnFiber,</span></span>
<span class="line"><span style="color:#E1E4E8;">    currentFirstChild,</span></span>
<span class="line"><span style="color:#E1E4E8;">    newChild,</span></span>
<span class="line"><span style="color:#E1E4E8;">    lanes,</span></span>
<span class="line"><span style="color:#E1E4E8;"> ),</span></span>
<span class="line"><span style="color:#E1E4E8;">);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">placeSingleChild</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">reconcileSingleElement</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">    returnFiber,</span></span>
<span class="line"><span style="color:#24292E;">    currentFirstChild,</span></span>
<span class="line"><span style="color:#24292E;">    newChild,</span></span>
<span class="line"><span style="color:#24292E;">    lanes,</span></span>
<span class="line"><span style="color:#24292E;"> ),</span></span>
<span class="line"><span style="color:#24292E;">);</span></span></code></pre></div><p>在<code>reconcileSingleElement</code>方法里会校验<code>key</code>和<code>type</code>是否一致，如果一致则使用<code>useFiber</code>方法进行复用<code>fiber</code>。<code>useFiber</code>方法会调用<code>createWorkInProgress</code>方法：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> workInProgress </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> current.alternate;</span></span>
<span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (workInProgress </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// ...</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 真实节点也被复用了</span></span>
<span class="line"><span style="color:#E1E4E8;">  workInProgress.stateNode </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> current.stateNode;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 每次创建的时候会建立相应的关系</span></span>
<span class="line"><span style="color:#E1E4E8;">  workInProgress.alternate </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> current;</span></span>
<span class="line"><span style="color:#E1E4E8;">  current.alternate </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> workInProgress;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> workInProgress </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> current.alternate;</span></span>
<span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (workInProgress </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// ...</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 真实节点也被复用了</span></span>
<span class="line"><span style="color:#24292E;">  workInProgress.stateNode </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> current.stateNode;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 每次创建的时候会建立相应的关系</span></span>
<span class="line"><span style="color:#24292E;">  workInProgress.alternate </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> current;</span></span>
<span class="line"><span style="color:#24292E;">  current.alternate </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> workInProgress;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>如果<code>current.alternate</code>不存在，那么会以<code>current</code>为基准，创建新的<code>fiber</code>，<strong>并且新的fiber和current之间通过alternate属性建立联系。除此之外，新的fiber还会复用current的stateNode，实际上是复用了fiber对应的真实节点。</strong></p><p>如果<code>key</code>或者<code>type</code>不一致时，会调用<code>createFiberFromElement</code>方法根据<code>jsx</code>解析出来的<code>ReactElement</code>创建新的<code>fiber</code>，该方法又会调用<code>createFiberFromTypeAndProps</code>方法来创建<code>fiber</code>，在<code>ReactFiber.new.js</code>文件中找到<code>createFiberFromTypeAndProps</code>方法：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">typeof</span><span style="color:#E1E4E8;"> type </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;function&#39;</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">shouldConstruct</span><span style="color:#E1E4E8;">(type)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    fiberTag </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> ClassComponent;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">typeof</span><span style="color:#24292E;"> type </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;function&#39;</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">shouldConstruct</span><span style="color:#24292E;">(type)) {</span></span>
<span class="line"><span style="color:#24292E;">    fiberTag </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> ClassComponent;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="type-function" tabindex="-1">type === function <a class="header-anchor" href="#type-function" aria-label="Permalink to &quot;type === function&quot;">​</a></h3><p>如果<code>type</code>为<code>function</code>，可能是<code>class</code>组件也可能是函数组件。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">shouldConstruct</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">Component</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Function</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">prototype</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">Component</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">prototype</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">!!</span><span style="color:#E1E4E8;">(prototype </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> prototype.isReactComponent);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">shouldConstruct</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">Component</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Function</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">prototype</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">Component</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">prototype</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">!!</span><span style="color:#24292E;">(prototype </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> prototype.isReactComponent);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>如果<code>shouldConstruct(type)</code>为<code>true</code>，说明<code>isReactComponent</code>存在。但是<code>isReactComponent</code>在哪里定义的呢？我们在写类组件的时候通常会写<code>extends Component</code>，在<code>ReactBaseClass.new.js</code>文件中找到<code>Component</code>的定义：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Component</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">props</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">context</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">updater</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.props </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> props;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.context </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> context;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.refs </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> emptyObject;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.updater </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> updater </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> ReactNoopUpdateQueue;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#79B8FF;">Component</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">prototype</span><span style="color:#E1E4E8;">.isReactComponent </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {};</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Component</span><span style="color:#24292E;">(</span><span style="color:#E36209;">props</span><span style="color:#24292E;">, </span><span style="color:#E36209;">context</span><span style="color:#24292E;">, </span><span style="color:#E36209;">updater</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.props </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> props;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.context </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> context;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.refs </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> emptyObject;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.updater </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> updater </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> ReactNoopUpdateQueue;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#005CC5;">Component</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">prototype</span><span style="color:#24292E;">.isReactComponent </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {};</span></span></code></pre></div><p>可以看出<code>class</code>组件的<code>isReactComponent</code>是存在的，也就是当<code>shouldConstruct(type)</code>存在时，表示他为<code>class</code>组件。</p><h3 id="type-string" tabindex="-1">type === string <a class="header-anchor" href="#type-string" aria-label="Permalink to &quot;type === string&quot;">​</a></h3><p>当<code>type</code>为<code>string</code>的时候，说明是普通标签，统一标记为<code>HostComponent</code></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">typeof</span><span style="color:#E1E4E8;"> type </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;string&#39;</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;"> fiberTag </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> HostComponent;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">typeof</span><span style="color:#24292E;"> type </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;string&#39;</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;"> fiberTag </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> HostComponent;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="其他-type" tabindex="-1">其他 type <a class="header-anchor" href="#其他-type" aria-label="Permalink to &quot;其他 type&quot;">​</a></h3><p>其他的都是<code>React</code>定义的一些<code>type</code>，比如<code>REACT_FRAGMENT_TYPE</code>、<code>REACT_SUSPENSE_TYPE</code>等。需要注意的是<code>type</code>为<code>object</code>的时候，<code>REACT_PROVIDER_TYPE</code>、<code>REACT_CONTEXT_TYPE</code>等<code>fiber</code>是在这个位置创建的。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">typeof</span><span style="color:#E1E4E8;"> type </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;object&#39;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> type </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">switch</span><span style="color:#E1E4E8;"> (type.$$typeof) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">REACT_PROVIDER_TYPE</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">   fiberTag </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> ContextProvider;</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getTag</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">REACT_CONTEXT_TYPE</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">   fiberTag </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> ContextConsumer;</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getTag</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">REACT_FORWARD_REF_TYPE</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">      fiberTag </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> ForwardRef;</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getTag</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">REACT_MEMO_TYPE</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">   fiberTag </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> MemoComponent;</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getTag</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">REACT_LAZY_TYPE</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">   fiberTag </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> LazyComponent;</span></span>
<span class="line"><span style="color:#E1E4E8;">   resolvedType </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getTag</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;"> }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">typeof</span><span style="color:#24292E;"> type </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;object&#39;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> type </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#D73A49;">switch</span><span style="color:#24292E;"> (type.$$typeof) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">REACT_PROVIDER_TYPE</span><span style="color:#24292E;">:</span></span>
<span class="line"><span style="color:#24292E;">   fiberTag </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> ContextProvider;</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">break</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getTag</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">REACT_CONTEXT_TYPE</span><span style="color:#24292E;">:</span></span>
<span class="line"><span style="color:#24292E;">   fiberTag </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> ContextConsumer;</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">break</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getTag</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">REACT_FORWARD_REF_TYPE</span><span style="color:#24292E;">:</span></span>
<span class="line"><span style="color:#24292E;">      fiberTag </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> ForwardRef;</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">break</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getTag</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">REACT_MEMO_TYPE</span><span style="color:#24292E;">:</span></span>
<span class="line"><span style="color:#24292E;">   fiberTag </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> MemoComponent;</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">break</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getTag</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">REACT_LAZY_TYPE</span><span style="color:#24292E;">:</span></span>
<span class="line"><span style="color:#24292E;">   fiberTag </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> LazyComponent;</span></span>
<span class="line"><span style="color:#24292E;">   resolvedType </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">break</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getTag</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;"> }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="创建-fiber" tabindex="-1">创建 fiber <a class="header-anchor" href="#创建-fiber" aria-label="Permalink to &quot;创建 fiber&quot;">​</a></h3><p>标记完<code>fiberTag</code>，最后开始创建<code>fiber</code>：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">fiber</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">createFiber</span><span style="color:#E1E4E8;">(fiberTag, pendingProps, key, mode);</span></span>
<span class="line"><span style="color:#E1E4E8;">fiber.elementType </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> type;</span></span>
<span class="line"><span style="color:#E1E4E8;">fiber.type </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> resolvedType;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">fiber</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">createFiber</span><span style="color:#24292E;">(fiberTag, pendingProps, key, mode);</span></span>
<span class="line"><span style="color:#24292E;">fiber.elementType </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> type;</span></span>
<span class="line"><span style="color:#24292E;">fiber.type </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> resolvedType;</span></span></code></pre></div><p>这里的<code>fiberTag</code>是<code>React</code>中对应的一套标签<code>Tag</code>。<code>elementType</code>是<code>jsx</code>解析出来的<code>type</code>，而<code>fiber.type</code>则是处理过后的<code>type</code>，因此<code>elementType</code>和<code>type</code>会存在不一致的情况。</p><h2 id="diff-算法" tabindex="-1">diff 算法 <a class="header-anchor" href="#diff-算法" aria-label="Permalink to &quot;diff 算法&quot;">​</a></h2><p>回到<code>reconcileChildFibers</code>方法，除了对象形式的<code>newChild</code>外，还可能存在数组形式的<code>newChild</code>，会进入<code>isArray</code>分支：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark has-diff vp-code-dark"><code><span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">isArray</span><span style="color:#E1E4E8;">(newChild)) {</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">// diff 算法</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">reconcileChildrenArray</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">  returnFiber,</span></span>
<span class="line"><span style="color:#E1E4E8;">  currentFirstChild,</span></span>
<span class="line"><span style="color:#E1E4E8;">  newChild,</span></span>
<span class="line"><span style="color:#E1E4E8;">  lanes,</span></span>
<span class="line"><span style="color:#E1E4E8;"> );</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light has-diff vp-code-light"><code><span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">isArray</span><span style="color:#24292E;">(newChild)) {</span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#6A737D;">// diff 算法</span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">reconcileChildrenArray</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">  returnFiber,</span></span>
<span class="line"><span style="color:#24292E;">  currentFirstChild,</span></span>
<span class="line"><span style="color:#24292E;">  newChild,</span></span>
<span class="line"><span style="color:#24292E;">  lanes,</span></span>
<span class="line"><span style="color:#24292E;"> );</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这个分支的主要作用就是对比<code>newChild</code>(也就是<code>jsx</code>接下出来的<code>ReactElement</code>)和已有的老<code>fiber</code>结构，进行复用<code>fiber</code>和真实节点，并且对<code>fiber</code>标记删除、替换等操作。这个对比的过程就是<code>diff</code>算法。</p><h3 id="对比开始部分" tabindex="-1">对比开始部分 <a class="header-anchor" href="#对比开始部分" aria-label="Permalink to &quot;对比开始部分&quot;">​</a></h3><p>以一个简单的例子开始：假如老节点<code>A，B，C，D，E</code>对应5个老<code>fiber</code>，现在新节点解析出来的是<code>A，B，D，E，F</code>5个<code>ReactElement</code>（在未处理成<code>fiber</code>之前）。最开始时我们需要依次从头到尾进行对比(主要是对比<code>key</code>和<code>type</code>两个属性)，发现<code>A，B</code>是可以复用的，但是<code>C</code>和<code>D</code>不一致，不能复用，此时退出当前对比部分。<code>React</code>这部分对比的代码如下：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// oldFiber 是老 fiber 的第一个 child，可以通过 sibling 进行遍历。</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> oldFiber </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> currentFirstChild;</span></span>
<span class="line"><span style="color:#6A737D;">// lastPlacedIndex 表示最后一个老fiber被复用的位置</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> lastPlacedIndex </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#6A737D;">// 表示新 ReactElement 的位置</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> newIdx </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#6A737D;">// 表示下一个老fiber</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> nextOldFiber </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// Diff 算法，标记子节点中需要的操作，记录在 flags 中</span></span>
<span class="line"><span style="color:#6A737D;">// 这个位置相当于只对比了前面的一部分，</span></span>
<span class="line"><span style="color:#6A737D;">// 如果出现 key 和 type 不一致的情况，那么会跳出对比。</span></span>
<span class="line"><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (;oldFiber </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> newIdx </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> newChildren.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;">;newIdx</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (oldFiber.index </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> newIdx) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 这里相当于 一直找到 old fiber index 与 newIdx 相等的节点</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 否则的话，oldFiber 不向后遍历。</span></span>
<span class="line"><span style="color:#E1E4E8;">    nextOldFiber </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> oldFiber;</span></span>
<span class="line"><span style="color:#E1E4E8;">    oldFiber </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 遍历下一个 fiber </span></span>
<span class="line"><span style="color:#E1E4E8;">    nextOldFiber </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> oldFiber.sibling;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 这里的 newChildren 是 jsx 解析出来的 children，为 ReactElement节点</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 根据节点创建或者更新 fiber</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">newFiber</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">updateSlot</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">    returnFiber,</span></span>
<span class="line"><span style="color:#E1E4E8;">    oldFiber, </span><span style="color:#6A737D;">// 老 fiber</span></span>
<span class="line"><span style="color:#E1E4E8;">    newChildren[newIdx], </span><span style="color:#6A737D;">// 新 element</span></span>
<span class="line"><span style="color:#E1E4E8;">    lanes,</span></span>
<span class="line"><span style="color:#E1E4E8;">  );</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// key 或 type 不相同时，不可复用。</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 此时 newFiber 为 null，对比就会终止。</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 这就意味着找到了第一个无法复用的节点</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (newFiber </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (oldFiber </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      oldFiber </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nextOldFiber;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 首次创建的时候无需记录，但是更新的时候需要记录</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (shouldTrackSideEffects) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (oldFiber </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> newFiber.alternate </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 将老的fiber标记为删除</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#B392F0;">deleteChild</span><span style="color:#E1E4E8;">(returnFiber, oldFiber);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 取 current.index 和 lastPlacedIndex 最大值</span></span>
<span class="line"><span style="color:#E1E4E8;">  lastPlacedIndex </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">placeChild</span><span style="color:#E1E4E8;">(newFiber, lastPlacedIndex, newIdx);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 建立 新fiber 之间的联系</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (previousNewFiber </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    resultingFirstChild </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> newFiber;</span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    previousNewFiber.sibling </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> newFiber;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  previousNewFiber </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> newFiber;</span></span>
<span class="line"><span style="color:#E1E4E8;">  oldFiber </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nextOldFiber;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// oldFiber 是老 fiber 的第一个 child，可以通过 sibling 进行遍历。</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> oldFiber </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> currentFirstChild;</span></span>
<span class="line"><span style="color:#6A737D;">// lastPlacedIndex 表示最后一个老fiber被复用的位置</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> lastPlacedIndex </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#6A737D;">// 表示新 ReactElement 的位置</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> newIdx </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#6A737D;">// 表示下一个老fiber</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> nextOldFiber </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// Diff 算法，标记子节点中需要的操作，记录在 flags 中</span></span>
<span class="line"><span style="color:#6A737D;">// 这个位置相当于只对比了前面的一部分，</span></span>
<span class="line"><span style="color:#6A737D;">// 如果出现 key 和 type 不一致的情况，那么会跳出对比。</span></span>
<span class="line"><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (;oldFiber </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> newIdx </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> newChildren.</span><span style="color:#005CC5;">length</span><span style="color:#24292E;">;newIdx</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (oldFiber.index </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> newIdx) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 这里相当于 一直找到 old fiber index 与 newIdx 相等的节点</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 否则的话，oldFiber 不向后遍历。</span></span>
<span class="line"><span style="color:#24292E;">    nextOldFiber </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> oldFiber;</span></span>
<span class="line"><span style="color:#24292E;">    oldFiber </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 遍历下一个 fiber </span></span>
<span class="line"><span style="color:#24292E;">    nextOldFiber </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> oldFiber.sibling;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 这里的 newChildren 是 jsx 解析出来的 children，为 ReactElement节点</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 根据节点创建或者更新 fiber</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">newFiber</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">updateSlot</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">    returnFiber,</span></span>
<span class="line"><span style="color:#24292E;">    oldFiber, </span><span style="color:#6A737D;">// 老 fiber</span></span>
<span class="line"><span style="color:#24292E;">    newChildren[newIdx], </span><span style="color:#6A737D;">// 新 element</span></span>
<span class="line"><span style="color:#24292E;">    lanes,</span></span>
<span class="line"><span style="color:#24292E;">  );</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// key 或 type 不相同时，不可复用。</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 此时 newFiber 为 null，对比就会终止。</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 这就意味着找到了第一个无法复用的节点</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (newFiber </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (oldFiber </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      oldFiber </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nextOldFiber;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 首次创建的时候无需记录，但是更新的时候需要记录</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (shouldTrackSideEffects) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (oldFiber </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> newFiber.alternate </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 将老的fiber标记为删除</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6F42C1;">deleteChild</span><span style="color:#24292E;">(returnFiber, oldFiber);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 取 current.index 和 lastPlacedIndex 最大值</span></span>
<span class="line"><span style="color:#24292E;">  lastPlacedIndex </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">placeChild</span><span style="color:#24292E;">(newFiber, lastPlacedIndex, newIdx);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 建立 新fiber 之间的联系</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (previousNewFiber </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    resultingFirstChild </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> newFiber;</span></span>
<span class="line"><span style="color:#24292E;">  } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    previousNewFiber.sibling </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> newFiber;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  previousNewFiber </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> newFiber;</span></span>
<span class="line"><span style="color:#24292E;">  oldFiber </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nextOldFiber;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>遍历跳出之后，会判断老<code>fiber</code>或者是新<code>ReactElement</code>遍历完成没。如果新<code>ReactElement</code>遍历完成，那么所有剩余的老<code>fiber</code>都应该标记为删除：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (newIdx </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> newChildren.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 标记删除，记录到 父 fiber 的 deletions 属性中</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">deleteRemainingChildren</span><span style="color:#E1E4E8;">(returnFiber, oldFiber);</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> resultingFirstChild;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (newIdx </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> newChildren.</span><span style="color:#005CC5;">length</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 标记删除，记录到 父 fiber 的 deletions 属性中</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">deleteRemainingChildren</span><span style="color:#24292E;">(returnFiber, oldFiber);</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> resultingFirstChild;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>如果老<code>fiber</code>遍历完成，那么所有剩余新的<code>ReactElement</code>都是新插入的节点，创建<code>newFiber</code></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (oldFiber </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (;newIdx </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> newChildren.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;">;newIdx</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">newFiber</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">createChild</span><span style="color:#E1E4E8;">(returnFiber, newChildren[newIdx], lanes);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (newFiber </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">continue</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    lastPlacedIndex </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">placeChild</span><span style="color:#E1E4E8;">(newFiber, lastPlacedIndex, newIdx);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (previousNewFiber </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      resultingFirstChild </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> newFiber;</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      previousNewFiber.sibling </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> newFiber;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    previousNewFiber </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> newFiber;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> resultingFirstChild;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (oldFiber </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (;newIdx </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> newChildren.</span><span style="color:#005CC5;">length</span><span style="color:#24292E;">;newIdx</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">newFiber</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">createChild</span><span style="color:#24292E;">(returnFiber, newChildren[newIdx], lanes);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (newFiber </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">continue</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    lastPlacedIndex </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">placeChild</span><span style="color:#24292E;">(newFiber, lastPlacedIndex, newIdx);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (previousNewFiber </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      resultingFirstChild </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> newFiber;</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">      previousNewFiber.sibling </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> newFiber;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    previousNewFiber </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> newFiber;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> resultingFirstChild;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>显然例子中还剩余<code>C，D，E</code>和<code>D，E，F</code>没有进行对比。</p><h3 id="对比剩余部分" tabindex="-1">对比剩余部分 <a class="header-anchor" href="#对比剩余部分" aria-label="Permalink to &quot;对比剩余部分&quot;">​</a></h3><p>如果老<code>fiber</code>和新<code>ReactElement</code>都有剩余，那么寻找可复用的<code>fiber</code>。对比代码如下：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 后续的是因为 key 和 type 不一致导致没有遍历完的数组。</span></span>
<span class="line"><span style="color:#6A737D;">// 此时开始复用的算法。</span></span>
<span class="line"><span style="color:#6A737D;">// 首先将老节点转换为 map 形式：{ key|index : fiber }</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">existingChildren</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">mapRemainingChildren</span><span style="color:#E1E4E8;">(returnFiber, oldFiber);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (;newIdx </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> newChildren.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;">;newIdx</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 找到相应的可复用的 fiber</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">newFiber</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">updateFromMap</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">    existingChildren,</span></span>
<span class="line"><span style="color:#E1E4E8;">    returnFiber,</span></span>
<span class="line"><span style="color:#E1E4E8;">    newIdx,</span></span>
<span class="line"><span style="color:#E1E4E8;">    newChildren[newIdx],</span></span>
<span class="line"><span style="color:#E1E4E8;">    lanes,</span></span>
<span class="line"><span style="color:#E1E4E8;">  );</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 如果找到了对应的 fiber</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (newFiber </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (shouldTrackSideEffects) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (newFiber.alternate </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 如果已经复用了，在老节点中删除对应的 fiber</span></span>
<span class="line"><span style="color:#E1E4E8;">        existingChildren.</span><span style="color:#B392F0;">delete</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">          newFiber.key </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> newIdx </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> newFiber.key,</span></span>
<span class="line"><span style="color:#E1E4E8;">        );</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 能复用时，更新最后一个复用的 老fiber 的 index</span></span>
<span class="line"><span style="color:#E1E4E8;">    lastPlacedIndex </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">placeChild</span><span style="color:#E1E4E8;">(newFiber, lastPlacedIndex, newIdx);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (previousNewFiber </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      resultingFirstChild </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> newFiber;</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      previousNewFiber.sibling </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> newFiber;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    previousNewFiber </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> newFiber;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (shouldTrackSideEffects) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 将所有没有被复用的老fiber标记为删除</span></span>
<span class="line"><span style="color:#E1E4E8;">  existingChildren.</span><span style="color:#B392F0;">forEach</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">child</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">deleteChild</span><span style="color:#E1E4E8;">(returnFiber, child));</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 后续的是因为 key 和 type 不一致导致没有遍历完的数组。</span></span>
<span class="line"><span style="color:#6A737D;">// 此时开始复用的算法。</span></span>
<span class="line"><span style="color:#6A737D;">// 首先将老节点转换为 map 形式：{ key|index : fiber }</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">existingChildren</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">mapRemainingChildren</span><span style="color:#24292E;">(returnFiber, oldFiber);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (;newIdx </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> newChildren.</span><span style="color:#005CC5;">length</span><span style="color:#24292E;">;newIdx</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 找到相应的可复用的 fiber</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">newFiber</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">updateFromMap</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">    existingChildren,</span></span>
<span class="line"><span style="color:#24292E;">    returnFiber,</span></span>
<span class="line"><span style="color:#24292E;">    newIdx,</span></span>
<span class="line"><span style="color:#24292E;">    newChildren[newIdx],</span></span>
<span class="line"><span style="color:#24292E;">    lanes,</span></span>
<span class="line"><span style="color:#24292E;">  );</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 如果找到了对应的 fiber</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (newFiber </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (shouldTrackSideEffects) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (newFiber.alternate </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 如果已经复用了，在老节点中删除对应的 fiber</span></span>
<span class="line"><span style="color:#24292E;">        existingChildren.</span><span style="color:#6F42C1;">delete</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">          newFiber.key </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> newIdx </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> newFiber.key,</span></span>
<span class="line"><span style="color:#24292E;">        );</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 能复用时，更新最后一个复用的 老fiber 的 index</span></span>
<span class="line"><span style="color:#24292E;">    lastPlacedIndex </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">placeChild</span><span style="color:#24292E;">(newFiber, lastPlacedIndex, newIdx);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (previousNewFiber </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      resultingFirstChild </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> newFiber;</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">      previousNewFiber.sibling </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> newFiber;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    previousNewFiber </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> newFiber;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (shouldTrackSideEffects) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 将所有没有被复用的老fiber标记为删除</span></span>
<span class="line"><span style="color:#24292E;">  existingChildren.</span><span style="color:#6F42C1;">forEach</span><span style="color:#24292E;">(</span><span style="color:#E36209;">child</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">deleteChild</span><span style="color:#24292E;">(returnFiber, child));</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这里最重要的一点是<code>placeChild</code>方法：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark has-diff vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 用于 diff 算法，标记最后匹配的 old fiber 的位置</span></span>
<span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">placeChild</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">newFiber</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Fiber</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">lastPlacedIndex</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">newIndex</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  newFiber.index </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> newIndex;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 当父亲的 current 不存在时，此时为 mount，shouldTrackSideEffects 为 false，不用做处理。</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 当父亲的 current 存在时，shouldTrackSideEffects 为 true。</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 例如，当遇到第一个需要重新创建的节点时，它对应的 parent 的 current 存在，标记为更新。</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 当遍历到子节点时，由于子节点对应的 parent 的 current 不存在，此时不标记更新。</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 这样做的好处是，只有父亲被标记为更新，而其后代均不作标记。</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 在 completeWork 的时候子节点直接全添加到父亲上。</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 在 commit 的时候只需要将父亲添加到 根节点上即可。</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">shouldTrackSideEffects) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> lastPlacedIndex;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 如果复用了 老fiber</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">current</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> newFiber.alternate;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (current </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">oldIndex</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> current.index;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 如果老的 index &lt; lastPlacedIndex，说明这些老的节点无法复用。</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (oldIndex </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> lastPlacedIndex) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 不可复用，需要替换</span></span>
<span class="line"><span style="color:#E1E4E8;">      newFiber.flags </span><span style="color:#F97583;">|=</span><span style="color:#E1E4E8;"> Placement;</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> lastPlacedIndex;</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// This item can stay in place.</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 否则说明这个老节点可以复用，返回老节点 index</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> oldIndex;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 如果 老 fiber不存在，那么需要替换</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 注意这里被标记了，commit的时候会进行处理</span></span>
<span class="line"><span style="color:#E1E4E8;">    newFiber.flags </span><span style="color:#F97583;">|=</span><span style="color:#E1E4E8;"> Placement;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> lastPlacedIndex;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light has-diff vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 用于 diff 算法，标记最后匹配的 old fiber 的位置</span></span>
<span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">placeChild</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">newFiber</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Fiber</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">lastPlacedIndex</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">number</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">newIndex</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">number</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">)</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">number</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  newFiber.index </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> newIndex;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 当父亲的 current 不存在时，此时为 mount，shouldTrackSideEffects 为 false，不用做处理。</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 当父亲的 current 存在时，shouldTrackSideEffects 为 true。</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 例如，当遇到第一个需要重新创建的节点时，它对应的 parent 的 current 存在，标记为更新。</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 当遍历到子节点时，由于子节点对应的 parent 的 current 不存在，此时不标记更新。</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 这样做的好处是，只有父亲被标记为更新，而其后代均不作标记。</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 在 completeWork 的时候子节点直接全添加到父亲上。</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 在 commit 的时候只需要将父亲添加到 根节点上即可。</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">shouldTrackSideEffects) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> lastPlacedIndex;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 如果复用了 老fiber</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">current</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> newFiber.alternate;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (current </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">oldIndex</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> current.index;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如果老的 index &lt; lastPlacedIndex，说明这些老的节点无法复用。</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (oldIndex </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> lastPlacedIndex) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 不可复用，需要替换</span></span>
<span class="line"><span style="color:#24292E;">      newFiber.flags </span><span style="color:#D73A49;">|=</span><span style="color:#24292E;"> Placement;</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> lastPlacedIndex;</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// This item can stay in place.</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 否则说明这个老节点可以复用，返回老节点 index</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> oldIndex;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">  } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如果 老 fiber不存在，那么需要替换</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 注意这里被标记了，commit的时候会进行处理</span></span>
<span class="line"><span style="color:#24292E;">    newFiber.flags </span><span style="color:#D73A49;">|=</span><span style="color:#24292E;"> Placement;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> lastPlacedIndex;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>该方法用于标记<code>fiber</code>是否为<code>Placement</code>。并且会更新<code>lastPlacedIndex</code>，该变量记录了最后一个被复用的老<code>fiber</code>的位置，因此这个老<code>fiber</code>前面的<code>fiber</code>就不应该被后续的<code>ReactElement</code>复用，从而达到移动的目的。比如<code>C，D，E</code>和<code>D，E，F</code>中<code>D</code>复用时，<code>lastPlacedIndex</code>为3，<code>E</code>复用时，<code>lastPlacedIndex</code>为4，<code>F</code>无法复用，此时创建新<code>fiber</code>，而老<code>fiber</code>中<code>C</code>没有被复用，那么会标记为删除。假设新的节点为 <code>D，E，C</code>，那么<code>C</code>会被复用吗？答案是不能，因为<code>lastPlacedIndex</code>为4，而老节点中<code>C</code>的位置为2，小于4，只能标记为删除，而不能复用。</p>`,69),e=[o];function c(r,t,E,y,i,d){return n(),a("div",null,e)}const C=s(p,[["render",c]]);export{b as __pageData,C as default};
