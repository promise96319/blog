import{_ as s}from"./chunks/life-of-a-frame.c78631ff.js";import{_ as n,o as a,c as l,Q as p}from"./chunks/framework.b96c6c14.js";const o="/assets/scheduler.0f2328c5.jpeg",e="/assets/scheduler-event-loop.a6170e51.jpeg",A=JSON.parse('{"title":"任务调度 Scheduler","description":"","frontmatter":{},"headers":[],"relativePath":"react/任务调度.md","filePath":"react/任务调度.md","lastUpdated":1698927986000}'),c={name:"react/任务调度.md"},t=p('<h1 id="任务调度-scheduler" tabindex="-1">任务调度 Scheduler <a class="header-anchor" href="#任务调度-scheduler" aria-label="Permalink to &quot;任务调度 Scheduler&quot;">​</a></h1><h2 id="调度总流程" tabindex="-1">调度总流程 <a class="header-anchor" href="#调度总流程" aria-label="Permalink to &quot;调度总流程&quot;">​</a></h2><p><img src="'+o+'" alt="img"></p><h2 id="时间切片" tabindex="-1">时间切片 <a class="header-anchor" href="#时间切片" aria-label="Permalink to &quot;时间切片&quot;">​</a></h2><p>在浏览器一帧章节里介绍到，在浏览器一帧里大致会有以下几个阶段：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">一个task</span><span style="color:#E1E4E8;">(宏任务) </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> 队列中全部微任务 </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> requestAnimationFrame </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> 浏览器重排</span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;">重绘 </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> requestIdleCallback</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">一个task</span><span style="color:#24292E;">(宏任务) </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> 队列中全部微任务 </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> requestAnimationFrame </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> 浏览器重排</span><span style="color:#D73A49;">/</span><span style="color:#24292E;">重绘 </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> requestIdleCallback</span></span></code></pre></div><p><img src="'+s+`" alt="img"></p><p>如果<code>React</code>的更新渲染层次比较深，渲染时间超过一帧（16.6ms）的时间，那么就会阻塞浏览器的重排/重绘。通常情况下，在100ms内用户感知不会很明显，但是超过这个值后就会感觉到卡顿。</p><p>在<code>ConcurrentMode</code>中，<code>React</code>通过<strong>时间切片</strong>的方法解决这一问题，通过将更新中的<code>render</code>阶段划分一个个的小任务，这个小任务指的是<code>beginWork</code> + <code>completeWork</code>两个阶段（<code>fiber</code>结构就是为了能方便的构建这些小任务），通常来说这些小任务连续执行的最长时间为<code>5ms</code>。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">workLoopConcurrent</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// shouldYield 代表这个任务开启的时间 与 现在的时间 之间的间隔是否大于 定义的时间间隔。</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 比如执行超过了 5ms 那么此时 shouldYield() 就为true，需要暂停渲染。</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (workInProgress </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">!</span><span style="color:#B392F0;">shouldYield</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">performUnitOfWork</span><span style="color:#E1E4E8;">(workInProgress);</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">workLoopConcurrent</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// shouldYield 代表这个任务开启的时间 与 现在的时间 之间的间隔是否大于 定义的时间间隔。</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 比如执行超过了 5ms 那么此时 shouldYield() 就为true，需要暂停渲染。</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (workInProgress </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">!</span><span style="color:#6F42C1;">shouldYield</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">performUnitOfWork</span><span style="color:#24292E;">(workInProgress);</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h2 id="简单例子" tabindex="-1">简单例子 <a class="header-anchor" href="#简单例子" aria-label="Permalink to &quot;简单例子&quot;">​</a></h2><p>那么<code>React</code>是如何进行实现时间切片即任务最长连续执行时间为<code>5ms</code>的呢？以一个简单点的例子来讲：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">button</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">id</span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&quot;btn&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">onclick</span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&quot;handle()&quot;</span><span style="color:#E1E4E8;">&gt;点击事件&lt;/</span><span style="color:#85E89D;">button</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  function handle() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;click 事件触发 &#39;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  function performUnitOfWork() {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#B392F0;">performUnitOfWork</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  performUnitOfWork()</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">button</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">id</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;btn&quot;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">onclick</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;handle()&quot;</span><span style="color:#24292E;">&gt;点击事件&lt;/</span><span style="color:#22863A;">button</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">script</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  function handle() {</span></span>
<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;click 事件触发 &#39;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  function performUnitOfWork() {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6F42C1;">performUnitOfWork</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  performUnitOfWork()</span></span>
<span class="line"><span style="color:#24292E;">&lt;/</span><span style="color:#22863A;">script</span><span style="color:#24292E;">&gt;</span></span></code></pre></div><p>在上面的代码中当点击按钮时，并不会触发事件。因为<code>performUnitOfWork</code>是同步循环执行，会导致完全没有时间执行其他任务，以及浏览器也不会进行重排重绘。这样<code>handle</code>的代码也就不会执行了。那么怎样才能使得<code>handle</code>中的代码有时间执行呢？在浏览器帧章节里提到，一次渲染中可以执行多次的宏任务，并且浏览器会自己来调节具体执行多少次，而且一般不会阻塞正常渲染。那么代码可以改写如下：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">button</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">id</span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&quot;btn&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">onclick</span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&quot;handle()&quot;</span><span style="color:#E1E4E8;">&gt;点击事件&lt;/</span><span style="color:#85E89D;">button</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  function handle() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;click 事件触发 &#39;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  function performUnitOfWork() {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#B392F0;">setTimeout</span><span style="color:#E1E4E8;">(performUnitOfWork)</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  performUnitOfWork()</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">button</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">id</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;btn&quot;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">onclick</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;handle()&quot;</span><span style="color:#24292E;">&gt;点击事件&lt;/</span><span style="color:#22863A;">button</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">script</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  function handle() {</span></span>
<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;click 事件触发 &#39;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  function performUnitOfWork() {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6F42C1;">setTimeout</span><span style="color:#24292E;">(performUnitOfWork)</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  performUnitOfWork()</span></span>
<span class="line"><span style="color:#24292E;">&lt;/</span><span style="color:#22863A;">script</span><span style="color:#24292E;">&gt;</span></span></code></pre></div><p>改写成这样后，<code>click</code>事件就能触发了，触发的顺序如下图所示：</p><p><img src="`+e+`" alt="img"></p><p>这样就能在渲染任务中间穿插执行其他任务了，但是如何保证渲染任务中连续执行的小任务只执行<code>5ms</code>，并且保证留有足够的时间给浏览器执行其他任务和渲染呢？这就要使用到<code>shouldYield()</code>方法了。<strong>每次执行一个小任务时记录开始时间，下次执行的时候看与开始时间是否相隔超过5ms，如果没有超过继续执行下一个小任务，此时均为同步执行。如果超过5ms就跳出当前任务，并设置一个宏任务开始下一轮事件循环</strong>。这样它们之间就留有充足的时间执行其他任务了。</p><h2 id="schedulecallback" tabindex="-1">scheduleCallback <a class="header-anchor" href="#schedulecallback" aria-label="Permalink to &quot;scheduleCallback&quot;">​</a></h2><p>调度的过程通过<code>Scheduler</code>包实现。在<code>ensureRootIsScheduled</code>方法中，会开始调度：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">newCallbackNode </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">scheduleCallback</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">  schedulerPriorityLevel,</span></span>
<span class="line"><span style="color:#E1E4E8;">  performConcurrentWorkOnRoot.</span><span style="color:#B392F0;">bind</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">, root),</span></span>
<span class="line"><span style="color:#E1E4E8;">)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">newCallbackNode </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">scheduleCallback</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">  schedulerPriorityLevel,</span></span>
<span class="line"><span style="color:#24292E;">  performConcurrentWorkOnRoot.</span><span style="color:#6F42C1;">bind</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">null</span><span style="color:#24292E;">, root),</span></span>
<span class="line"><span style="color:#24292E;">)</span></span></code></pre></div><p><code>scheduleCallback</code>方法主要任务是按照一定的优先级执行一个函数，注意<code>performConcurrentWorkOnRoot.bind(null, root)</code>是一个函数，而不是函数执行的结果。</p><p><code>scheduleCallback</code>方法是调用了<code>Scheduler</code>包的<code>unstable_scheduleCallback</code>方法，打开文件<code>shceduler/src/forks/Scheduler.js</code>文件，<code>unstable_scheduleCallback</code>首先会根据<code>options</code>的<code>delay</code>计算任务的真正的开始时间<code>startTime</code>。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> currentTime </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getCurrentTime</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 起始时间</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> startTime;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">typeof</span><span style="color:#E1E4E8;"> options </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;object&#39;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> options </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> delay </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> options.delay;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">typeof</span><span style="color:#E1E4E8;"> delay </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;number&#39;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> delay </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      startTime </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> currentTime </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> delay;</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      startTime </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> currentTime;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    startTime </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> currentTime;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">var</span><span style="color:#24292E;"> currentTime </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getCurrentTime</span><span style="color:#24292E;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 起始时间</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">var</span><span style="color:#24292E;"> startTime;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">typeof</span><span style="color:#24292E;"> options </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;object&#39;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> options </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">var</span><span style="color:#24292E;"> delay </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> options.delay;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">typeof</span><span style="color:#24292E;"> delay </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;number&#39;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> delay </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      startTime </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> currentTime </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> delay;</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">      startTime </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> currentTime;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">  } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    startTime </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> currentTime;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span></code></pre></div><p>然后根据优先级设置不同的<code>timeout</code>，优先级越低的任务，就放到越后面执行：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> timeout;</span></span>
<span class="line"><span style="color:#F97583;">switch</span><span style="color:#E1E4E8;"> (priorityLevel) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> ImmediatePriority:</span></span>
<span class="line"><span style="color:#E1E4E8;">    timeout </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">IMMEDIATE_PRIORITY_TIMEOUT</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> UserBlockingPriority:</span></span>
<span class="line"><span style="color:#E1E4E8;">    timeout </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">USER_BLOCKING_PRIORITY_TIMEOUT</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> IdlePriority:</span></span>
<span class="line"><span style="color:#E1E4E8;">    timeout </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">IDLE_PRIORITY_TIMEOUT</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> LowPriority:</span></span>
<span class="line"><span style="color:#E1E4E8;">    timeout </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">LOW_PRIORITY_TIMEOUT</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> NormalPriority:</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">default</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">    timeout </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">NORMAL_PRIORITY_TIMEOUT</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> expirationTime </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> startTime </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> timeout;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">var</span><span style="color:#24292E;"> timeout;</span></span>
<span class="line"><span style="color:#D73A49;">switch</span><span style="color:#24292E;"> (priorityLevel) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> ImmediatePriority:</span></span>
<span class="line"><span style="color:#24292E;">    timeout </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">IMMEDIATE_PRIORITY_TIMEOUT</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> UserBlockingPriority:</span></span>
<span class="line"><span style="color:#24292E;">    timeout </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">USER_BLOCKING_PRIORITY_TIMEOUT</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> IdlePriority:</span></span>
<span class="line"><span style="color:#24292E;">    timeout </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">IDLE_PRIORITY_TIMEOUT</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> LowPriority:</span></span>
<span class="line"><span style="color:#24292E;">    timeout </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">LOW_PRIORITY_TIMEOUT</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> NormalPriority:</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">default</span><span style="color:#24292E;">:</span></span>
<span class="line"><span style="color:#24292E;">    timeout </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">NORMAL_PRIORITY_TIMEOUT</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#D73A49;">var</span><span style="color:#24292E;"> expirationTime </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> startTime </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> timeout;</span></span></code></pre></div><p><code>expirationTime</code>代表加入优先级后，任务应该开始执行的时间。随后根据开始时间和过期时间创建一个任务：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> newTask </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 任务id</span></span>
<span class="line"><span style="color:#E1E4E8;">    id: taskIdCounter</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 任务的执行内容</span></span>
<span class="line"><span style="color:#E1E4E8;">    callback,</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 任务的优先级</span></span>
<span class="line"><span style="color:#E1E4E8;">    priorityLevel,</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 任务的实际开始时间</span></span>
<span class="line"><span style="color:#E1E4E8;">    startTime,</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 任务加入优先级后的开始时间，称为过期时间</span></span>
<span class="line"><span style="color:#E1E4E8;">    expirationTime,</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 任务排序的index，这里为过期时间，优先级越低，排序越靠后</span></span>
<span class="line"><span style="color:#E1E4E8;">    sortIndex: </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  };</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">var</span><span style="color:#24292E;"> newTask </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 任务id</span></span>
<span class="line"><span style="color:#24292E;">    id: taskIdCounter</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 任务的执行内容</span></span>
<span class="line"><span style="color:#24292E;">    callback,</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 任务的优先级</span></span>
<span class="line"><span style="color:#24292E;">    priorityLevel,</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 任务的实际开始时间</span></span>
<span class="line"><span style="color:#24292E;">    startTime,</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 任务加入优先级后的开始时间，称为过期时间</span></span>
<span class="line"><span style="color:#24292E;">    expirationTime,</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 任务排序的index，这里为过期时间，优先级越低，排序越靠后</span></span>
<span class="line"><span style="color:#24292E;">    sortIndex: </span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  };</span></span></code></pre></div><p><code>React</code>中任务队列有两种，一种是<code>taskQueue</code>，当任务<code>startTime</code>小于等于<code>currentTime</code>时，任务都会放入到<code>taskQueue</code>中。另一种是<code>timerQueue</code>，当任务<code>startTime</code>大于<code>currentTime</code>时，任务都会放入到<code>timerQueue</code>中。每次执行任务时会通过<code>advanceTimers</code>方法检测<code>currentTime</code>，如果<code>currentTime</code>大于<code>startTime</code>，那么就会将该任务从<code>timerQueue</code>中添加到<code>taskQueue</code>中。这两个任务队列都是<strong>最小堆</strong>结构，过期时间越小，最先执行。</p><p>对于<code>taskQueue</code>，会调用<code>requestHostCallback</code>方法执行任务。如果<code>taskQueue</code>为空，就会在<code>timerQueue</code>中寻找最先的任务，并通过<code>requestHostTimeout</code>方法设置一个定时器执行任务。</p><p>最终都会调用<code>requestHostCallback</code>中的<code>schedulePerformWorkUntilDeadline</code>开始任务。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> schedulePerformWorkUntilDeadline;</span></span>
<span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">typeof</span><span style="color:#E1E4E8;"> localSetImmediate </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;function&#39;</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">schedulePerformWorkUntilDeadline</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">localSetImmediate</span><span style="color:#E1E4E8;">(performWorkUntilDeadline);</span></span>
<span class="line"><span style="color:#E1E4E8;">  };</span></span>
<span class="line"><span style="color:#E1E4E8;">} </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">typeof</span><span style="color:#E1E4E8;"> MessageChannel </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;undefined&#39;</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">channel</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">MessageChannel</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">port</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> channel.port2;</span></span>
<span class="line"><span style="color:#E1E4E8;">  channel.port1.onmessage </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> performWorkUntilDeadline;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">schedulePerformWorkUntilDeadline</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    port.</span><span style="color:#B392F0;">postMessage</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">  };</span></span>
<span class="line"><span style="color:#E1E4E8;">} </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">schedulePerformWorkUntilDeadline</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">localSetTimeout</span><span style="color:#E1E4E8;">(performWorkUntilDeadline, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">  };</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> schedulePerformWorkUntilDeadline;</span></span>
<span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">typeof</span><span style="color:#24292E;"> localSetImmediate </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;function&#39;</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">schedulePerformWorkUntilDeadline</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> () </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">localSetImmediate</span><span style="color:#24292E;">(performWorkUntilDeadline);</span></span>
<span class="line"><span style="color:#24292E;">  };</span></span>
<span class="line"><span style="color:#24292E;">} </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">typeof</span><span style="color:#24292E;"> MessageChannel </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;undefined&#39;</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">channel</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">MessageChannel</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">port</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> channel.port2;</span></span>
<span class="line"><span style="color:#24292E;">  channel.port1.onmessage </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> performWorkUntilDeadline;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">schedulePerformWorkUntilDeadline</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> () </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    port.</span><span style="color:#6F42C1;">postMessage</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">null</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">  };</span></span>
<span class="line"><span style="color:#24292E;">} </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">schedulePerformWorkUntilDeadline</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> () </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">localSetTimeout</span><span style="color:#24292E;">(performWorkUntilDeadline, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">  };</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这里相当于开启了一个宏任务，最后会执行<code>performWorkUntilDeadline</code>方法。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">performWorkUntilDeadline</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">currentTime</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getCurrentTime</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">  startTime </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> currentTime;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">hasTimeRemaining</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> hasMoreWork </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// scheduledHostCallback 这里指的是 flushWork.</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 如果是时间到了，那么他就会暂停，然后返回说还有更多任务，</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 此时调用 schedulePerformWorkUntilDeadline。</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 相当于执行了一个异步任务，而在这个任务之间，可以接受一些用户操作之类的任务进来，而不是直接阻塞！</span></span>
<span class="line"><span style="color:#E1E4E8;">    hasMoreWork </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">scheduledHostCallback</span><span style="color:#E1E4E8;">(hasTimeRemaining, currentTime);</span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span><span style="color:#F97583;">finally</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (hasMoreWork) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 如果有更多的任务，开始下一个宏任务。</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#B392F0;">schedulePerformWorkUntilDeadline</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      isMessageLoopRunning </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">      scheduledHostCallback </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">performWorkUntilDeadline</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> () </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">currentTime</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getCurrentTime</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">  startTime </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> currentTime;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">hasTimeRemaining</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> hasMoreWork </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// scheduledHostCallback 这里指的是 flushWork.</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如果是时间到了，那么他就会暂停，然后返回说还有更多任务，</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 此时调用 schedulePerformWorkUntilDeadline。</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 相当于执行了一个异步任务，而在这个任务之间，可以接受一些用户操作之类的任务进来，而不是直接阻塞！</span></span>
<span class="line"><span style="color:#24292E;">    hasMoreWork </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">scheduledHostCallback</span><span style="color:#24292E;">(hasTimeRemaining, currentTime);</span></span>
<span class="line"><span style="color:#24292E;">  } </span><span style="color:#D73A49;">finally</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (hasMoreWork) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 如果有更多的任务，开始下一个宏任务。</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6F42C1;">schedulePerformWorkUntilDeadline</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">      isMessageLoopRunning </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">      scheduledHostCallback </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">};</span></span></code></pre></div><p>这里<code>scheduledHostCallback</code>方法对应的是<code>flushWork</code>方法:</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">flushWork</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">hasTimeRemaining</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">initialTime</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">workLoop</span><span style="color:#E1E4E8;">(hasTimeRemaining, initialTime);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">flushWork</span><span style="color:#24292E;">(</span><span style="color:#E36209;">hasTimeRemaining</span><span style="color:#24292E;">, </span><span style="color:#E36209;">initialTime</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">workLoop</span><span style="color:#24292E;">(hasTimeRemaining, initialTime);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h2 id="workloop" tabindex="-1">workLoop <a class="header-anchor" href="#workloop" aria-label="Permalink to &quot;workLoop&quot;">​</a></h2><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">workLoop</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">hasTimeRemaining</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">initialTime</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 当前任务的执行时间</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> currentTime </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> initialTime;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 调整 timers，将已到时间的 timer 放入到 taskQueue 中</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">advanceTimers</span><span style="color:#E1E4E8;">(currentTime);</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 取出第一个任务</span></span>
<span class="line"><span style="color:#E1E4E8;">  currentTask </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">peek</span><span style="color:#E1E4E8;">(taskQueue);</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (</span></span>
<span class="line"><span style="color:#E1E4E8;">    currentTask </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">(enableSchedulerDebugging </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> isSchedulerPaused)</span></span>
<span class="line"><span style="color:#E1E4E8;">  ) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 任务未过期，且没有多余的时间可供执行，退出循环。</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 过期时间只是用作判断最迟的执行时间，并且用于排序。</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// startTime 才是一个任务真正应该的起始时间。</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 如果任务未过期，但是里面的startTime都已经开始了，此时有剩余执行时间，依然是可以执行的。</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span></span>
<span class="line"><span style="color:#E1E4E8;">      currentTask.expirationTime </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> currentTime </span><span style="color:#F97583;">&amp;&amp;</span></span>
<span class="line"><span style="color:#E1E4E8;">      (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">hasTimeRemaining </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">shouldYieldToHost</span><span style="color:#E1E4E8;">())</span></span>
<span class="line"><span style="color:#E1E4E8;">    ) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 如果任务没有过期，且没有多余时间执行任务，那么就会退出执行。</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">callback</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> currentTask.callback;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">typeof</span><span style="color:#E1E4E8;"> callback </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;function&#39;</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      currentTask.callback </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">      currentPriorityLevel </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> currentTask.priorityLevel;</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 是否属于过期的任务，可能存在还没过期的任务。</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">didUserCallbackTimeout</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> currentTask.expirationTime </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> currentTime;</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 执行任务</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">continuationCallback</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">callback</span><span style="color:#E1E4E8;">(didUserCallbackTimeout);</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 如果是 yield，那么说明时间到了，会返回有一个 perform 函数</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 该函数主要用于继续执行后续 render</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 更新执行完后的时间</span></span>
<span class="line"><span style="color:#E1E4E8;">      currentTime </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getCurrentTime</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">typeof</span><span style="color:#E1E4E8;"> continuationCallback </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;function&#39;</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 如果执行完后又返回了 function，赋值给当前任务的callback</span></span>
<span class="line"><span style="color:#E1E4E8;">        currentTask.callback </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> continuationCallback;</span></span>
<span class="line"><span style="color:#E1E4E8;">      } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 否则的话，将当前任务移除。中断在这个位置发生，高优先任务会把低优先任务的callback置空。</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (currentTask </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">peek</span><span style="color:#E1E4E8;">(taskQueue)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#B392F0;">pop</span><span style="color:#E1E4E8;">(taskQueue);</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 更新 timerQueue</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#B392F0;">advanceTimers</span><span style="color:#E1E4E8;">(currentTime);</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 移除 task</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#B392F0;">pop</span><span style="color:#E1E4E8;">(taskQueue);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 取任务</span></span>
<span class="line"><span style="color:#E1E4E8;">    currentTask </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">peek</span><span style="color:#E1E4E8;">(taskQueue);</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (currentTask </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 返回是否还有任务</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 说明 currentTask 执行完了</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">firstTimer</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">peek</span><span style="color:#E1E4E8;">(timerQueue);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (firstTimer </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 处理 timerQueue</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#B392F0;">requestHostTimeout</span><span style="color:#E1E4E8;">(handleTimeout, firstTimer.startTime </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> currentTime);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">workLoop</span><span style="color:#24292E;">(</span><span style="color:#E36209;">hasTimeRemaining</span><span style="color:#24292E;">, </span><span style="color:#E36209;">initialTime</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 当前任务的执行时间</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> currentTime </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> initialTime;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 调整 timers，将已到时间的 timer 放入到 taskQueue 中</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">advanceTimers</span><span style="color:#24292E;">(currentTime);</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 取出第一个任务</span></span>
<span class="line"><span style="color:#24292E;">  currentTask </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">peek</span><span style="color:#24292E;">(taskQueue);</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (</span></span>
<span class="line"><span style="color:#24292E;">    currentTask </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">!</span><span style="color:#24292E;">(enableSchedulerDebugging </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> isSchedulerPaused)</span></span>
<span class="line"><span style="color:#24292E;">  ) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 任务未过期，且没有多余的时间可供执行，退出循环。</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 过期时间只是用作判断最迟的执行时间，并且用于排序。</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// startTime 才是一个任务真正应该的起始时间。</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如果任务未过期，但是里面的startTime都已经开始了，此时有剩余执行时间，依然是可以执行的。</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span></span>
<span class="line"><span style="color:#24292E;">      currentTask.expirationTime </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> currentTime </span><span style="color:#D73A49;">&amp;&amp;</span></span>
<span class="line"><span style="color:#24292E;">      (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">hasTimeRemaining </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">shouldYieldToHost</span><span style="color:#24292E;">())</span></span>
<span class="line"><span style="color:#24292E;">    ) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 如果任务没有过期，且没有多余时间执行任务，那么就会退出执行。</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">callback</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> currentTask.callback;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">typeof</span><span style="color:#24292E;"> callback </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;function&#39;</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      currentTask.callback </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">      currentPriorityLevel </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> currentTask.priorityLevel;</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 是否属于过期的任务，可能存在还没过期的任务。</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">didUserCallbackTimeout</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> currentTask.expirationTime </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> currentTime;</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 执行任务</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">continuationCallback</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">callback</span><span style="color:#24292E;">(didUserCallbackTimeout);</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 如果是 yield，那么说明时间到了，会返回有一个 perform 函数</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 该函数主要用于继续执行后续 render</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 更新执行完后的时间</span></span>
<span class="line"><span style="color:#24292E;">      currentTime </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getCurrentTime</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">typeof</span><span style="color:#24292E;"> continuationCallback </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;function&#39;</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 如果执行完后又返回了 function，赋值给当前任务的callback</span></span>
<span class="line"><span style="color:#24292E;">        currentTask.callback </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> continuationCallback;</span></span>
<span class="line"><span style="color:#24292E;">      } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 否则的话，将当前任务移除。中断在这个位置发生，高优先任务会把低优先任务的callback置空。</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (currentTask </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">peek</span><span style="color:#24292E;">(taskQueue)) {</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#6F42C1;">pop</span><span style="color:#24292E;">(taskQueue);</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 更新 timerQueue</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6F42C1;">advanceTimers</span><span style="color:#24292E;">(currentTime);</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 移除 task</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6F42C1;">pop</span><span style="color:#24292E;">(taskQueue);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 取任务</span></span>
<span class="line"><span style="color:#24292E;">    currentTask </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">peek</span><span style="color:#24292E;">(taskQueue);</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (currentTask </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 返回是否还有任务</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 说明 currentTask 执行完了</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">firstTimer</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">peek</span><span style="color:#24292E;">(timerQueue);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (firstTimer </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 处理 timerQueue</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6F42C1;">requestHostTimeout</span><span style="color:#24292E;">(handleTimeout, firstTimer.startTime </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> currentTime);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这里的<code>callback</code>对应<code>performConcurrentWorkOnRoot.bind(null, root)</code>方法：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">continuationCallback</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">callback</span><span style="color:#E1E4E8;">(didUserCallbackTimeout);</span></span>
<span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">typeof</span><span style="color:#E1E4E8;"> continuationCallback </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;function&#39;</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;"> currentTask.callback </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> continuationCallback;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">continuationCallback</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">callback</span><span style="color:#24292E;">(didUserCallbackTimeout);</span></span>
<span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">typeof</span><span style="color:#24292E;"> continuationCallback </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;function&#39;</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;"> currentTask.callback </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> continuationCallback;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h2 id="performconcurrentworkonroot" tabindex="-1">performConcurrentWorkOnRoot <a class="header-anchor" href="#performconcurrentworkonroot" aria-label="Permalink to &quot;performConcurrentWorkOnRoot&quot;">​</a></h2><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">performConcurrentWorkOnRoot</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">root</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">didTimeout</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// didTimeout 表示任务的 过期时间 &gt; 当前的执行时间，而且此时是有执行的空闲时间的。</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 如果有用户输入的 lane 或者 过期 lane，并且上述条件满足，</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 那么会执行 renderRootConcurrent，否则按同步执行。</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// shouldTimeSlice 会判断当前是 默认还是有用户输入，如果是的话就是同步渲染。</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// didTimeout 表示当前的任务是否过期，如果过期了，那么同步执行。否则并发执行。</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> exitStatus </span><span style="color:#F97583;">=</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">shouldTimeSlice</span><span style="color:#E1E4E8;">(root, lanes) </span><span style="color:#F97583;">&amp;&amp;</span></span>
<span class="line"><span style="color:#E1E4E8;">      (disableSchedulerTimeoutInWorkLoop </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">didTimeout)</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">renderRootConcurrent</span><span style="color:#E1E4E8;">(root, lanes)</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">renderRootSync</span><span style="color:#E1E4E8;">(root, lanes);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 完成后，继续 schedule，发现没有 lane 就退出了</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 相当于判断这里有没有更高优先级的任务,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 如果没有, 那么下面的比较会执行，然后 performConcurrentWorkOnRoot</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 否则 callbackNode.callback = null </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">ensureRootIsScheduled</span><span style="color:#E1E4E8;">(root, </span><span style="color:#B392F0;">now</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// originalCallbackNode 是在这之前赋值的</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 中间经历了 render 阶段 + commit 阶段，如果完成了话，那么 callbackNode 为 null</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 如果任务被打断了，root.callbackNode 也为 null</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (root.callbackNode </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> originalCallbackNode) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// The task node scheduled for this root is the same one that&#39;s</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// currently executed. Need to return a continuation.</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 这里相当于又将当前任务返回去了，那么任务就还是现在的任务。</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> performConcurrentWorkOnRoot.</span><span style="color:#B392F0;">bind</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">, root);</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">performConcurrentWorkOnRoot</span><span style="color:#24292E;">(</span><span style="color:#E36209;">root</span><span style="color:#24292E;">, </span><span style="color:#E36209;">didTimeout</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// didTimeout 表示任务的 过期时间 &gt; 当前的执行时间，而且此时是有执行的空闲时间的。</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 如果有用户输入的 lane 或者 过期 lane，并且上述条件满足，</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 那么会执行 renderRootConcurrent，否则按同步执行。</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// shouldTimeSlice 会判断当前是 默认还是有用户输入，如果是的话就是同步渲染。</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// didTimeout 表示当前的任务是否过期，如果过期了，那么同步执行。否则并发执行。</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> exitStatus </span><span style="color:#D73A49;">=</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">shouldTimeSlice</span><span style="color:#24292E;">(root, lanes) </span><span style="color:#D73A49;">&amp;&amp;</span></span>
<span class="line"><span style="color:#24292E;">      (disableSchedulerTimeoutInWorkLoop </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">!</span><span style="color:#24292E;">didTimeout)</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">renderRootConcurrent</span><span style="color:#24292E;">(root, lanes)</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">renderRootSync</span><span style="color:#24292E;">(root, lanes);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 完成后，继续 schedule，发现没有 lane 就退出了</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 相当于判断这里有没有更高优先级的任务,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 如果没有, 那么下面的比较会执行，然后 performConcurrentWorkOnRoot</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 否则 callbackNode.callback = null </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">ensureRootIsScheduled</span><span style="color:#24292E;">(root, </span><span style="color:#6F42C1;">now</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">  </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// originalCallbackNode 是在这之前赋值的</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 中间经历了 render 阶段 + commit 阶段，如果完成了话，那么 callbackNode 为 null</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 如果任务被打断了，root.callbackNode 也为 null</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (root.callbackNode </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> originalCallbackNode) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// The task node scheduled for this root is the same one that&#39;s</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// currently executed. Need to return a continuation.</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 这里相当于又将当前任务返回去了，那么任务就还是现在的任务。</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> performConcurrentWorkOnRoot.</span><span style="color:#6F42C1;">bind</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">null</span><span style="color:#24292E;">, root);</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p><code>performConcurrentWorkOnRoot</code>函数在允许时间切片的情况下会调用<code>workLoopConcurrent</code>方法：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">workLoopConcurrent</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// shouldYield 代表这个任务开启的时间 与 现在的时间 之间的间隔是否大于 定义的时间间隔。</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 比如执行超过了 5ms 那么此时 shouldYield() 就为true，需要暂停渲染。</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (workInProgress </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">!</span><span style="color:#B392F0;">shouldYield</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">performUnitOfWork</span><span style="color:#E1E4E8;">(workInProgress);</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">workLoopConcurrent</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// shouldYield 代表这个任务开启的时间 与 现在的时间 之间的间隔是否大于 定义的时间间隔。</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 比如执行超过了 5ms 那么此时 shouldYield() 就为true，需要暂停渲染。</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (workInProgress </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">!</span><span style="color:#6F42C1;">shouldYield</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">performUnitOfWork</span><span style="color:#24292E;">(workInProgress);</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>该方法判断如果<code>workInProgress</code>为空的话，那么说明任务完成了，后续会进行<code>commit</code>阶段，最后该任务完成，<code>root.callbackNode</code>置为<code>null</code>，这样<code>Scheduler</code>里的<code>continuationCallback</code>就是<code>null</code>，就会移除当前任务，开启下一个任务。</p><p>如果<code>workInProgress</code>不为空的话，判断<code>shouleYield</code>，也就是<code>Scheduler</code>中的 <code>shouldYieldToHost</code>方法：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">shouldYieldToHost</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 获取当前时间，减去这个任务的开始时间</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">timeElapsed</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getCurrentTime</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> startTime;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 如果间隔时间小于 frameInterval，默认 5ms</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 说明执行时间充足，可以继续执行，否则说明时间不充足，将会暂停执行。</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (timeElapsed </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> frameInterval) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">shouldYieldToHost</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 获取当前时间，减去这个任务的开始时间</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">timeElapsed</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getCurrentTime</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> startTime;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 如果间隔时间小于 frameInterval，默认 5ms</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 说明执行时间充足，可以继续执行，否则说明时间不充足，将会暂停执行。</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (timeElapsed </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> frameInterval) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>如果时间小于<code>5ms</code>，那么可以继续执行，否则就会跳出执行<code>ensureRootIsScheduled(root, now())</code>。如果检测到有新的任务进来，优先级发生变化，那么<code>callbackNode</code>就会置为<code>null</code>，此时<code>continuationCallback</code>为<code>null</code>，会移除当前任务（也就是优先级低的任务），开启高优先级任务。</p><p>否则的话，任务优先级未变化，此时<code>callbackNode === originalCallbackNode</code>，会返回<code>performConcurrentWorkOnRoot.bind(null, root)</code>，也就是<code>Scheduler</code>中的<code>continuationCallback</code>为函数，该任务<code>callback</code>存在，循环后又会执行<code>performConcurrentWorkOnRoot</code>：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">continuationCallback</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">callback</span><span style="color:#E1E4E8;">(didUserCallbackTimeout)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">continuationCallback</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">callback</span><span style="color:#24292E;">(didUserCallbackTimeout)</span></span></code></pre></div><p>这样就就可以进行高优先级任务打断低优先级任务了。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p><code>React</code>使用<code>fiber</code>将原本一次性的更新分为了一个个的小任务。而且这些小任务的连续执行时间通常为<code>5ms</code>，这样就可以使得其他任务得到执行。</p><p>在执行完<code>5ms</code>的任务后，会检测是否有更高优先级的任务进来。如果有的话，将低优先级任务取消，即将<code>callback</code>置为<code>null</code>，开启高优先级任务。</p>`,54),r=[t];function E(y,i,d,u,F,m){return a(),l("div",null,r)}const h=n(c,[["render",E]]);export{A as __pageData,h as default};
