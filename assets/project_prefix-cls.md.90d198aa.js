import{_ as s,o as a,c as n,Q as l}from"./chunks/framework.92ce8a2a.js";const C=JSON.parse('{"title":"组件库样式覆盖问题","description":"","frontmatter":{},"headers":[],"relativePath":"project/prefix-cls.md","filePath":"project/prefix-cls.md","lastUpdated":1695719180000}'),o={name:"project/prefix-cls.md"},p=l(`<h1 id="组件库样式覆盖问题" tabindex="-1">组件库样式覆盖问题 <a class="header-anchor" href="#组件库样式覆盖问题" aria-label="Permalink to &quot;组件库样式覆盖问题&quot;">​</a></h1><h2 id="问题背景" tabindex="-1">问题背景 <a class="header-anchor" href="#问题背景" aria-label="Permalink to &quot;问题背景&quot;">​</a></h2><p>目前公司内部通过联邦模块将项目架构分为三层：</p><ul><li><code>Platform</code>：为项目底座，实现项目的一些通用功能。</li><li><code>App</code>：各个项目。</li><li><code>Widget</code>：动态业务组件。</li></ul><p>三者的渲染关系相当于：</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">Platform</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;</span><span style="color:#79B8FF;">App</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;</span><span style="color:#79B8FF;">Widget</span><span style="color:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;/</span><span style="color:#79B8FF;">App</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#79B8FF;">Platform</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#005CC5;">Platform</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  &lt;</span><span style="color:#005CC5;">App</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">    &lt;</span><span style="color:#005CC5;">Widget</span><span style="color:#24292E;"> /&gt;</span></span>
<span class="line"><span style="color:#24292E;">  &lt;/</span><span style="color:#005CC5;">App</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">&lt;/</span><span style="color:#005CC5;">Platform</span><span style="color:#24292E;">&gt;</span></span></code></pre></div><p>由于 <code>Platform/App/Widget</code> 都会引入 <code>@qt/design</code> 组件库，当它们对组件库的样式进行覆盖时，就会相互影响，导致样式异常，并且这种影响是不可控的。</p><p>为了解决样式覆盖相互影响的问题，需要对组件库添加类名前缀用于样式覆盖。</p><h2 id="业界方案" tabindex="-1">业界方案 <a class="header-anchor" href="#业界方案" aria-label="Permalink to &quot;业界方案&quot;">​</a></h2><ul><li>Ant Design： <ul><li>v4.x： <ul><li>js 层面：组件类名通过 <code>ConfigProvider</code> 下传，组件将前缀进行拼接。</li><li>css 层面： 通过 <code>less-loader</code> 自带的 <code>modifyVars</code> 参数对 <code>css</code> 变量进行替换。</li></ul></li><li>v5.x：采用 <code>css in js</code> 的方案，运行时即可将 js/css 前缀进行替换。</li></ul></li><li>Arco Design / Semi Design / TDesign <ul><li>这些开源组件库的样式前缀方案大都与 Ant Design v4.x 实现思路相同。</li></ul></li></ul><h2 id="采取方案" tabindex="-1">采取方案 <a class="header-anchor" href="#采取方案" aria-label="Permalink to &quot;采取方案&quot;">​</a></h2><p><code>@qt/design</code> 同样采取 <code>ConfigProvider</code> 的方式，来给组件库添加类名前缀。具体实现如下：</p><h3 id="组件库-js" tabindex="-1">组件库 js <a class="header-anchor" href="#组件库-js" aria-label="Permalink to &quot;组件库 js&quot;">​</a></h3><p>通过 <code>ConfigProvider</code> 向下传递 <code>prefixCls</code>，组件库内部通过 <code>ConfigContext</code> 获取 <code>prefixCls</code>，并且将前缀拼接到组件类名上。</p><h3 id="组件库-css" tabindex="-1">组件库 css <a class="header-anchor" href="#组件库-css" aria-label="Permalink to &quot;组件库 css&quot;">​</a></h3><p>组件库内部样式定义均以 <code>$qtc-prefix</code> 变量开头，项目中提供该 <code>$qtc-prefix</code> 变量即可。</p><h3 id="项目中使用" tabindex="-1">项目中使用 <a class="header-anchor" href="#项目中使用" aria-label="Permalink to &quot;项目中使用&quot;">​</a></h3><p>每个独立的 <code>App</code> 都需要添加自己的类名前缀及样式前缀，覆盖时通过带有前缀的类名进行覆盖，这样多个项目间的样式覆盖就不会互相影响了，最终项目的渲染关系如下：</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">Config.Provider</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">value</span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">{{ prefixCls: </span><span style="color:#9ECBFF;">&#39;platform&#39;</span><span style="color:#E1E4E8;"> }}&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;</span><span style="color:#79B8FF;">Platform</span><span style="color:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;</span><span style="color:#79B8FF;">Config.Provider</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">value</span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">{{ prefixCls: </span><span style="color:#9ECBFF;">&#39;app&#39;</span><span style="color:#E1E4E8;"> }}&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;</span><span style="color:#79B8FF;">App</span><span style="color:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;</span><span style="color:#79B8FF;">Config.Provider</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">value</span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">{{ prefixCls: </span><span style="color:#9ECBFF;">&#39;widget&#39;</span><span style="color:#E1E4E8;"> }}&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">      &lt;</span><span style="color:#79B8FF;">Widget</span><span style="color:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;/</span><span style="color:#79B8FF;">Config.Provider</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;/</span><span style="color:#79B8FF;">Config.Provider</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#79B8FF;">Config.Provider</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#005CC5;">Config.Provider</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">value</span><span style="color:#D73A49;">=</span><span style="color:#24292E;">{{ prefixCls: </span><span style="color:#032F62;">&#39;platform&#39;</span><span style="color:#24292E;"> }}&gt;</span></span>
<span class="line"><span style="color:#24292E;">  &lt;</span><span style="color:#005CC5;">Platform</span><span style="color:#24292E;"> /&gt;</span></span>
<span class="line"><span style="color:#24292E;">  &lt;</span><span style="color:#005CC5;">Config.Provider</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">value</span><span style="color:#D73A49;">=</span><span style="color:#24292E;">{{ prefixCls: </span><span style="color:#032F62;">&#39;app&#39;</span><span style="color:#24292E;"> }}&gt;</span></span>
<span class="line"><span style="color:#24292E;">    &lt;</span><span style="color:#005CC5;">App</span><span style="color:#24292E;"> /&gt;</span></span>
<span class="line"><span style="color:#24292E;">    &lt;</span><span style="color:#005CC5;">Config.Provider</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">value</span><span style="color:#D73A49;">=</span><span style="color:#24292E;">{{ prefixCls: </span><span style="color:#032F62;">&#39;widget&#39;</span><span style="color:#24292E;"> }}&gt;</span></span>
<span class="line"><span style="color:#24292E;">      &lt;</span><span style="color:#005CC5;">Widget</span><span style="color:#24292E;"> /&gt;</span></span>
<span class="line"><span style="color:#24292E;">    &lt;/</span><span style="color:#005CC5;">Config.Provider</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  &lt;/</span><span style="color:#005CC5;">Config.Provider</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">&lt;/</span><span style="color:#005CC5;">Config.Provider</span><span style="color:#24292E;">&gt;</span></span></code></pre></div><h2 id="其他问题" tabindex="-1">其他问题 <a class="header-anchor" href="#其他问题" aria-label="Permalink to &quot;其他问题&quot;">​</a></h2><h3 id="静态方法问题" tabindex="-1">静态方法问题 <a class="header-anchor" href="#静态方法问题" aria-label="Permalink to &quot;静态方法问题&quot;">​</a></h3><p>对于组件库的静态方法（如 <code>Modal.confirm()/Message.success()</code>）来讲， <code>Config Context</code> 无法透传到这些静态方法上，导致类名前缀失效。目前其他开源库主要有两种处理方案：</p><h4 id="全局变量" tabindex="-1">全局变量 <a class="header-anchor" href="#全局变量" aria-label="Permalink to &quot;全局变量&quot;">​</a></h4><p>大多数开源组件库采用的是全局变量的方法，将 <code>Config Context</code> 在 <code>ConfigProvider</code> 的时候存到全局变量中，当调用静态方法时，从全局变量中获取 <code>Config Context</code>。</p><p>这种方法能在一定的程度上解决 <code>Context 断开的问题</code>，但是实际上项目中使用到的其他 <code>context</code> 遇到静态方法时，同样会遇到 <code>Context 断开的问题</code>。</p><h4 id="通过-usemodal-usemessage-等方法来代替静态方法" tabindex="-1">通过 <code>useModal/useMessage</code> 等方法来代替静态方法 <a class="header-anchor" href="#通过-usemodal-usemessage-等方法来代替静态方法" aria-label="Permalink to &quot;通过 \`useModal/useMessage\` 等方法来代替静态方法&quot;">​</a></h4><p>Ant Design v5.x：使用 <code>useModal/useMessage</code> 等方法来代替这些静态方法，将 hook 中返回的 <code>placeholder</code> 节点放到 <code>jsx</code> 中，这样就能关联到 <code>jsx</code> 的上下文 ，从而获取到 <code>Config Context</code> 了。</p><p>这种方法的好处是不会丢失上下文，其他任何 <code>context</code> 都能透传到 <code>hook</code> 调用的方法中。缺点是使用起来没有静态方法方便，静态方法可以在任何位置调用。并且这种方法在组件的用法上需要做许多的改动，因此公司内组件库采用”全局变量“的方案来解决。</p><h3 id="多份-css-问题" tabindex="-1">多份 css 问题 <a class="header-anchor" href="#多份-css-问题" aria-label="Permalink to &quot;多份 css 问题&quot;">​</a></h3><p>前面提到业务中会采用 <code>Widget</code> 的方式来动态加载业务组件。一个 <code>App</code> 中可能会存在多个 <code>Widget</code>，如果每个 <code>Widget</code> 都包含自己的组件库，那么会导致最终产物的体积会变得非常大。</p><p>因此，我们希望 <code>Widget</code> 能直接使用宿主 <code>App</code> 的组件库，而不单独打包一份。（实际上 App 同样也可以使用 Platform 这个宿主的组件库，但是由于目前项目里组件库版本还未真正统一，所以会存在一定的问题。当然，同一份 widget 在不同的宿主环境中也会出现问题，目前暂不考虑）。</p><p>共享组件库在实现上并不难，在联邦模块中，可以通过 <code>shared</code> 共享组件库，使 <code>Widget</code> 使用 <code>App</code> 的组件库。但是共享后发现一个问题，由于前面静态方法采用 <code>全局变量</code> 的方案解决，当组件库被共享时，<code>Widget/App</code> 中的 <code>Config Context</code> 就会被相互覆盖，导致类名前缀不符合预期。</p><p>并且通过类名前缀的方式覆盖样式时，需要 <code>Widget/App</code> 各自生成一份自己的 <code>css</code> 文件，同样会使打包后的产物体积变大。</p><p>因此，我们需要找到一种方式，能够让 <code>Widget/App</code> 共享组件库，同时又能够保证类名前缀不会相互覆盖，最终只生成一份 <code>css</code> 文件。</p><p>基于此，我们将组件库的样式覆盖进行修改：</p><ul><li>当组件库被共享时，依旧使用原始的类名前缀，不做任何修改，保留组件库原有的样式。</li><li>当需要覆盖组件库样式时，组件库提供一个 <code>Context</code>，可以设置类名作用空间，如 <code>namespace</code>，其下的所有节点的类名都会附带这个类名空间，当进行样式覆盖时，通过 <code>原始类名.类名空间</code> 的方式进行覆盖，这样就不会影响到其他组件库的样式了。</li></ul><p>使用如下：</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">Config.Provider</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">value</span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">{{ namespace: </span><span style="color:#9ECBFF;">&#39;app&#39;</span><span style="color:#E1E4E8;"> }}&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;</span><span style="color:#79B8FF;">App</span><span style="color:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;</span><span style="color:#79B8FF;">Config.Provider</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">value</span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">{{ namespace: </span><span style="color:#9ECBFF;">&#39;widget&#39;</span><span style="color:#E1E4E8;"> }}&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;</span><span style="color:#79B8FF;">Widget</span><span style="color:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;/</span><span style="color:#79B8FF;">Config.Provider</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#79B8FF;">Config.Provider</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#005CC5;">Config.Provider</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">value</span><span style="color:#D73A49;">=</span><span style="color:#24292E;">{{ namespace: </span><span style="color:#032F62;">&#39;app&#39;</span><span style="color:#24292E;"> }}&gt;</span></span>
<span class="line"><span style="color:#24292E;">  &lt;</span><span style="color:#005CC5;">App</span><span style="color:#24292E;"> /&gt;</span></span>
<span class="line"><span style="color:#24292E;">  &lt;</span><span style="color:#005CC5;">Config.Provider</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">value</span><span style="color:#D73A49;">=</span><span style="color:#24292E;">{{ namespace: </span><span style="color:#032F62;">&#39;widget&#39;</span><span style="color:#24292E;"> }}&gt;</span></span>
<span class="line"><span style="color:#24292E;">    &lt;</span><span style="color:#005CC5;">Widget</span><span style="color:#24292E;"> /&gt;</span></span>
<span class="line"><span style="color:#24292E;">  &lt;/</span><span style="color:#005CC5;">Config.Provider</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">&lt;/</span><span style="color:#005CC5;">Config.Provider</span><span style="color:#24292E;">&gt;</span></span></code></pre></div><p>当需要覆盖样式时，比如覆盖 <code>App</code> 的 <code>card</code> 时，渲染的结果如下：</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">class</span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&quot;qtc-card app&quot;</span><span style="color:#E1E4E8;">&gt; // 对于 app 内的类名都会附加 app 类名空间</span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">class</span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&quot;qtc-card widget&quot;</span><span style="color:#E1E4E8;">&gt; // 对于 widget 内的类名都会附加 app 类名空间</span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;/</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">div</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">class</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;qtc-card app&quot;</span><span style="color:#24292E;">&gt; // 对于 app 内的类名都会附加 app 类名空间</span></span>
<span class="line"><span style="color:#24292E;">  &lt;</span><span style="color:#22863A;">div</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">class</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;qtc-card widget&quot;</span><span style="color:#24292E;">&gt; // 对于 widget 内的类名都会附加 app 类名空间</span></span>
<span class="line"><span style="color:#24292E;">  &lt;/</span><span style="color:#22863A;">div</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">&lt;/</span><span style="color:#22863A;">div</span><span style="color:#24292E;">&gt;</span></span></code></pre></div><p>对样式覆盖时，只需要指定相应的类名空间即可：</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">.qtc-button.app</span><span style="color:#E1E4E8;"> { </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">color</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">red</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">.qtc-button.app</span><span style="color:#24292E;"> { </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">color</span><span style="color:#24292E;">: </span><span style="color:#005CC5;">red</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>对于静态方法，如果要进行样式覆盖，可以给每个静态方法提供一个 <code>namespace</code> 的参数，用于设置类名空间，如：</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">Modal.</span><span style="color:#B392F0;">confirm</span><span style="color:#E1E4E8;">({ namespace: </span><span style="color:#9ECBFF;">&#39;app-namespace&#39;</span><span style="color:#E1E4E8;"> })</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">Modal.</span><span style="color:#6F42C1;">confirm</span><span style="color:#24292E;">({ namespace: </span><span style="color:#032F62;">&#39;app-namespace&#39;</span><span style="color:#24292E;"> })</span></span></code></pre></div><p>由于此时是有明确的样式覆盖需求，所以在这里指定相应的类名空间也不会显得突兀。</p>`,45),e=[p];function c(t,r,i,d,E,y){return a(),n("div",null,e)}const h=s(o,[["render",c]]);export{C as __pageData,h as default};
