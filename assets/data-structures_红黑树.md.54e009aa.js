import{_ as l,o as a,c as e,Q as t}from"./chunks/framework.b96c6c14.js";const r="/assets/red-black-tree-01.3b20064c.png",i="/assets/red-black-tree-02.205c08f6.png",o="/assets/red-black-tree-03.1e339ffc.png",s="/assets/red-black-tree-04.7bd7270c.png",k=JSON.parse('{"title":"红黑树","description":"","frontmatter":{},"headers":[],"relativePath":"data-structures/红黑树.md","filePath":"data-structures/红黑树.md","lastUpdated":1698927986000}'),n={name:"data-structures/红黑树.md"},c=t('<h1 id="红黑树" tabindex="-1">红黑树 <a class="header-anchor" href="#红黑树" aria-label="Permalink to &quot;红黑树&quot;">​</a></h1><h2 id="红黑树-vs-avl树" tabindex="-1">红黑树 vs AVL树 <a class="header-anchor" href="#红黑树-vs-avl树" aria-label="Permalink to &quot;红黑树 vs AVL树&quot;">​</a></h2><p>AVL是严格的平衡二叉树，无论是执行插入还是删除只要不满足要求都会进行旋转，而旋转时非常耗时的，所以AVL树更适合插入和删除比较少但查找多的情况。红黑树是一种弱平衡二叉树，他的旋转次数较AVL少许多，因此应用场景也相对广一些。</p><h2 id="性质" tabindex="-1">性质 <a class="header-anchor" href="#性质" aria-label="Permalink to &quot;性质&quot;">​</a></h2><ol><li>每个结点都是红色的或是黑色的</li><li>根结点是黑色的</li><li>每个叶结点是黑色的</li><li>如果一个结点是红色的，则它的两个子结点都是黑色的</li><li>对于每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色节点</li></ol><h2 id="插入" tabindex="-1">插入 <a class="header-anchor" href="#插入" aria-label="Permalink to &quot;插入&quot;">​</a></h2><ol><li>如果父结点为黑色结点，那么插入的红色结点不会影响平衡，跳过。</li><li>如果父结点为红色结点 <ol><li>如果叔结点为红色结点 <ol><li>父结点和叔结点变为黑色，祖父结点如果不是根结点则变红色</li><li>向上递归，继续平衡祖父结点</li></ol></li><li>如果叔结点不存在或是黑色结点 <ol><li>先进行旋转（同 AVL 树4种旋转方式）</li><li>父结点和祖父节点换颜色</li><li>向上递归，继续平衡祖父结点</li></ol></li></ol></li></ol><h2 id="删除" tabindex="-1">删除 <a class="header-anchor" href="#删除" aria-label="Permalink to &quot;删除&quot;">​</a></h2><ol><li>找到<strong>替换结点</strong>：左子树的最大值结点 or 右子树的最小值结点（类似于二叉查找树的删除结点）</li><li><strong>情景1</strong>：如果替换结点是红色，那么直接将替换节点值赋给删除结点，并删除替换结点。</li><li>如果替换结点是黑色： <ol><li><strong>情景2</strong>：如果替换结点是其父结点的左结点 <ol><li><strong>情景2.1</strong>：如果替换结点的兄弟结点是红色，删除黑结点会导致左侧黑色结点少一，此时通过交换兄弟结点和父结点颜色并向左旋转解决。（类似于右右的结点情况）<img src="'+r+'" alt="img"></li><li><strong>情景2.2</strong>：如果替换结点的兄弟结点是黑色，兄弟结点右结点为红色，左结点为任意颜色，此时不能通过情景2.1那样左旋达到平衡，而是需要将红色右子结点”借“过来。兄弟结点和父结点颜色对调，右子结点变为黑色，并进行左旋。<img src="'+i+'" alt="img"></li><li><strong>情景2.3</strong>：兄弟结点右结点为黑色，左结点为红色。此时左结点与兄弟结点交换颜色，并右旋。再进行情景2.2<img src="'+o+'" alt="img"></li><li><strong>情景2.4</strong>：兄弟结点子结点均为黑色。此时兄弟结点没有结点可以借了，只能向父结点借，把兄弟结点设为红色，将父结点作为新的替代结点，自底向上处理。 <img src="'+s+'" alt="img"></li></ol></li><li><strong>情景3</strong>：如果替换结点是其父结点的右结点，与左节点情况镜像</li></ol></li></ol><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li><a href="https://segmentfault.com/a/1190000014037447" target="_blank" rel="noreferrer">红黑树图示</a></li><li><a href="https://github.com/mymmsc/books/blob/master/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E4%B8%AD%E6%96%87%E7%89%88.pdf" target="_blank" rel="noreferrer">算法导论-红黑树</a></li><li><a href="https://www.jianshu.com/p/e136ec79235c" target="_blank" rel="noreferrer">30张图带你彻底理解红黑树</a></li><li><a href="https://blog.csdn.net/u010899985/article/details/80981053" target="_blank" rel="noreferrer">红黑树与AVL对比</a></li><li><a href="https://oi-wiki.org/ds/llrbt/" target="_blank" rel="noreferrer">oi-wiki</a></li><li><a href="https://segmentfault.com/a/1190000022278733" target="_blank" rel="noreferrer">红黑树删除</a></li><li><a href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html" target="_blank" rel="noreferrer">红黑树可视化过程</a></li></ul>',11),h=[c];function d(_,g,m,f,u,b){return a(),e("div",null,h)}const A=l(n,[["render",d]]);export{k as __pageData,A as default};
