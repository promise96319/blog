import{_ as s,o as n,c as a,Q as p}from"./chunks/framework.baea2d07.js";const A=JSON.parse('{"title":"插件开发","description":"","frontmatter":{},"headers":[],"relativePath":"babel/guide/plugin.md","filePath":"babel/guide/plugin.md","lastUpdated":1699268300000}'),l={name:"babel/guide/plugin.md"},o=p(`<h1 id="插件开发" tabindex="-1">插件开发 <a class="header-anchor" href="#插件开发" aria-label="Permalink to &quot;插件开发&quot;">​</a></h1><h2 id="plugin" tabindex="-1">plugin <a class="header-anchor" href="#plugin" aria-label="Permalink to &quot;plugin&quot;">​</a></h2><p>babel 提供了插件机制允许我们修改 AST。插件一般存在两种形式：函数形式和对象形式，函数形式返回的也是对象，这里主要以函数形式为例：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">export</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">default</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">babel</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">options</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">dirname</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">     inherits: parentPlugin,</span></span>
<span class="line"><span style="color:#E1E4E8;">     </span><span style="color:#B392F0;">manipulateOptions</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">options</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">parserOptions</span><span style="color:#E1E4E8;">) {},</span></span>
<span class="line"><span style="color:#E1E4E8;">     </span><span style="color:#B392F0;">pre</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">file</span><span style="color:#E1E4E8;">) {},</span></span>
<span class="line"><span style="color:#E1E4E8;">     visitor: {},</span></span>
<span class="line"><span style="color:#E1E4E8;">     </span><span style="color:#B392F0;">post</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">file</span><span style="color:#E1E4E8;">) {}</span></span>
<span class="line"><span style="color:#E1E4E8;">   };</span></span>
<span class="line"><span style="color:#E1E4E8;"> }</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;"> </span><span style="color:#D73A49;">export</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">default</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">function</span><span style="color:#24292E;">(</span><span style="color:#E36209;">babel</span><span style="color:#24292E;">, </span><span style="color:#E36209;">options</span><span style="color:#24292E;">, </span><span style="color:#E36209;">dirname</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">     inherits: parentPlugin,</span></span>
<span class="line"><span style="color:#24292E;">     </span><span style="color:#6F42C1;">manipulateOptions</span><span style="color:#24292E;">(</span><span style="color:#E36209;">options</span><span style="color:#24292E;">, </span><span style="color:#E36209;">parserOptions</span><span style="color:#24292E;">) {},</span></span>
<span class="line"><span style="color:#24292E;">     </span><span style="color:#6F42C1;">pre</span><span style="color:#24292E;">(</span><span style="color:#E36209;">file</span><span style="color:#24292E;">) {},</span></span>
<span class="line"><span style="color:#24292E;">     visitor: {},</span></span>
<span class="line"><span style="color:#24292E;">     </span><span style="color:#6F42C1;">post</span><span style="color:#24292E;">(</span><span style="color:#E36209;">file</span><span style="color:#24292E;">) {}</span></span>
<span class="line"><span style="color:#24292E;">   };</span></span>
<span class="line"><span style="color:#24292E;"> }</span></span></code></pre></div><p>其中 visitor 就是遍历 AST 时，对 AST 节点的访问，在这里可以做一些节点的修改。比如以 const 转换为 var 为例：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 插件</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">module</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">exports</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">babel</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">     visitor: {</span></span>
<span class="line"><span style="color:#E1E4E8;">       </span><span style="color:#B392F0;">VariableDeclaration</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">path</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">         </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (path.node.kind </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;const&#39;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">           path.node.kind </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;var&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">       },</span></span>
<span class="line"><span style="color:#E1E4E8;">     },</span></span>
<span class="line"><span style="color:#E1E4E8;">   }</span></span>
<span class="line"><span style="color:#E1E4E8;"> }</span></span>
<span class="line"><span style="color:#E1E4E8;"> ​</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">// 源码</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">a</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">// 生成代码</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> a </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 插件</span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#005CC5;">module</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">exports</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (</span><span style="color:#E36209;">babel</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">     visitor: {</span></span>
<span class="line"><span style="color:#24292E;">       </span><span style="color:#6F42C1;">VariableDeclaration</span><span style="color:#24292E;">(</span><span style="color:#E36209;">path</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">         </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (path.node.kind </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;const&#39;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">           path.node.kind </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;var&#39;</span></span>
<span class="line"><span style="color:#24292E;">       },</span></span>
<span class="line"><span style="color:#24292E;">     },</span></span>
<span class="line"><span style="color:#24292E;">   }</span></span>
<span class="line"><span style="color:#24292E;"> }</span></span>
<span class="line"><span style="color:#24292E;"> ​</span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#6A737D;">// 源码</span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">a</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#6A737D;">// 生成代码</span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#D73A49;">var</span><span style="color:#24292E;"> a </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span></code></pre></div><p>通过上面的例子可以看出 babel 可以通过插件，对代码进行各种各样的转换，因此我们需要使用新语法时只需要增加新语法的转换插件即可，比如装饰器 @babel/plugin-proposal-decorators，可选链 @babel/plugin-proposal-optional-chaining 等等。</p><h2 id="preset" tabindex="-1">preset <a class="header-anchor" href="#preset" aria-label="Permalink to &quot;preset&quot;">​</a></h2><p>plugin 是单个转换功能的实现，当 plugin 比较多或者 plugin 的 options 比较多的时候就会导致使用成本升高。这时候可以封装成一个 preset，用户可以通过 preset 来批量引入 plugin 并进行一些配置。</p><p>preset 就是对配置和插件的一层封装，其中最常见的就是 @babel/preset-env， 包含了一系列的语法转换插件，用户只需要指定相应的浏览器环境，它就提供相对应的语法转换插件。</p><p>preset 和 plugin 从形式上差不多，但是应用顺序不同。 babel 会按照如下顺序处理插件和 preset：</p><ul><li>先执行 plugin，再执行 preset</li><li>plugin 从前到后，preset 从后到前</li></ul><h2 id="path" tabindex="-1">path <a class="header-anchor" href="#path" aria-label="Permalink to &quot;path&quot;">​</a></h2><p>visitor 中的每个方法都会传入一个 path 对象，path 对象是对当前节点的抽象，它提供了一系列的方法来操作当前节点，比如修改节点、删除节点、插入节点等等。path 对象的属性和方法如下：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">path {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 属性：</span></span>
<span class="line"><span style="color:#E1E4E8;">  node </span><span style="color:#6A737D;">// 节点</span></span>
<span class="line"><span style="color:#E1E4E8;">  parent </span><span style="color:#6A737D;">// 父节点</span></span>
<span class="line"><span style="color:#E1E4E8;">  parentPath </span><span style="color:#6A737D;">// 父 path</span></span>
<span class="line"><span style="color:#E1E4E8;">  scope </span><span style="color:#6A737D;">// 作用域</span></span>
<span class="line"><span style="color:#E1E4E8;">  hub </span><span style="color:#6A737D;">// 可以通过 path.hub.file 拿到最外层 File 对象， path.hub.getScope 拿到最外层作用域，path.hub.getCode 拿到源码字符串</span></span>
<span class="line"><span style="color:#E1E4E8;">  container </span><span style="color:#6A737D;">// 当前 AST 节点所在的父节点属性的属性值</span></span>
<span class="line"><span style="color:#E1E4E8;">  key </span><span style="color:#6A737D;">// 当前 AST 节点所在父节点属性的属性名或所在数组的下标</span></span>
<span class="line"><span style="color:#E1E4E8;">  listKey </span><span style="color:#6A737D;">// 当前 AST 节点所在父节点属性的属性值为数组时 listkey 为该属性名，否则为 undefined</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 方法</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">inList</span><span style="color:#E1E4E8;">() </span><span style="color:#6A737D;">// 判断节点是否在数组中，如果 container 为数组，也就是有 listkey 的时候，返回 true</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(key) </span><span style="color:#6A737D;">// 获取某个属性的 path</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">set</span><span style="color:#E1E4E8;">(key, node) </span><span style="color:#6A737D;">// 设置某个属性的值</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">getSibling</span><span style="color:#E1E4E8;">(key) </span><span style="color:#6A737D;">// 获取某个下标的兄弟节点</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">getNextSibling</span><span style="color:#E1E4E8;">() </span><span style="color:#6A737D;">// 获取下一个兄弟节点</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">getPrevSibling</span><span style="color:#E1E4E8;">() </span><span style="color:#6A737D;">// 获取上一个兄弟节点</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">getAllPrevSiblings</span><span style="color:#E1E4E8;">() </span><span style="color:#6A737D;">// 获取之前的所有兄弟节点</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">getAllNextSiblings</span><span style="color:#E1E4E8;">() </span><span style="color:#6A737D;">// 获取之后的所有兄弟节点</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">isXxx</span><span style="color:#E1E4E8;">(opts) </span><span style="color:#6A737D;">// 判断当前节点是否是某个类型，可以传入属性和属性值进一步判断，比如path.isIdentifier({name: &#39;a&#39;})</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">assertXxx</span><span style="color:#E1E4E8;">(opts) </span><span style="color:#6A737D;">// 同 isXxx，但是不返回布尔值，而是抛出异常</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">find</span><span style="color:#E1E4E8;">(callback) </span><span style="color:#6A737D;">// 从当前节点到根节点来查找节点（包括当前节点），调用 callback（传入 path）来决定是否终止查找</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">findParent</span><span style="color:#E1E4E8;">(callback) </span><span style="color:#6A737D;">// 从当前节点到根节点来查找节点（不包括当前节点），调用 callback（传入 path）来决定是否终止查找</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">insertBefore</span><span style="color:#E1E4E8;">(nodes) </span><span style="color:#6A737D;">// 在之前插入节点，可以是单个节点或者节点数组</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">insertAfter</span><span style="color:#E1E4E8;">(nodes) </span><span style="color:#6A737D;">// 在之后插入节点，可以是单个节点或者节点数组</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">replaceWith</span><span style="color:#E1E4E8;">(replacement) </span><span style="color:#6A737D;">// 用某个节点替换当前节点</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">replaceWithMultiple</span><span style="color:#E1E4E8;">(nodes) </span><span style="color:#6A737D;">// 用多个节点替换当前节点</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">replaceWithSourceString</span><span style="color:#E1E4E8;">(replacement) </span><span style="color:#6A737D;">// 解析源码成 AST，然后替换当前节点</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">remove</span><span style="color:#E1E4E8;">() </span><span style="color:#6A737D;">// 删除当前节点</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">traverse</span><span style="color:#E1E4E8;">(visitor, state) </span><span style="color:#6A737D;">// 遍历当前节点的子节点，传入 visitor 和 state（state 是不同节点间传递数据的方式）</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">skip</span><span style="color:#E1E4E8;">() </span><span style="color:#6A737D;">// 跳过当前节点的子节点的遍历</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">stop</span><span style="color:#E1E4E8;">() </span><span style="color:#6A737D;">// 结束所有遍历</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">path {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 属性：</span></span>
<span class="line"><span style="color:#24292E;">  node </span><span style="color:#6A737D;">// 节点</span></span>
<span class="line"><span style="color:#24292E;">  parent </span><span style="color:#6A737D;">// 父节点</span></span>
<span class="line"><span style="color:#24292E;">  parentPath </span><span style="color:#6A737D;">// 父 path</span></span>
<span class="line"><span style="color:#24292E;">  scope </span><span style="color:#6A737D;">// 作用域</span></span>
<span class="line"><span style="color:#24292E;">  hub </span><span style="color:#6A737D;">// 可以通过 path.hub.file 拿到最外层 File 对象， path.hub.getScope 拿到最外层作用域，path.hub.getCode 拿到源码字符串</span></span>
<span class="line"><span style="color:#24292E;">  container </span><span style="color:#6A737D;">// 当前 AST 节点所在的父节点属性的属性值</span></span>
<span class="line"><span style="color:#24292E;">  key </span><span style="color:#6A737D;">// 当前 AST 节点所在父节点属性的属性名或所在数组的下标</span></span>
<span class="line"><span style="color:#24292E;">  listKey </span><span style="color:#6A737D;">// 当前 AST 节点所在父节点属性的属性值为数组时 listkey 为该属性名，否则为 undefined</span></span>
<span class="line"><span style="color:#24292E;">  </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 方法</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">inList</span><span style="color:#24292E;">() </span><span style="color:#6A737D;">// 判断节点是否在数组中，如果 container 为数组，也就是有 listkey 的时候，返回 true</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(key) </span><span style="color:#6A737D;">// 获取某个属性的 path</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">set</span><span style="color:#24292E;">(key, node) </span><span style="color:#6A737D;">// 设置某个属性的值</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">getSibling</span><span style="color:#24292E;">(key) </span><span style="color:#6A737D;">// 获取某个下标的兄弟节点</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">getNextSibling</span><span style="color:#24292E;">() </span><span style="color:#6A737D;">// 获取下一个兄弟节点</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">getPrevSibling</span><span style="color:#24292E;">() </span><span style="color:#6A737D;">// 获取上一个兄弟节点</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">getAllPrevSiblings</span><span style="color:#24292E;">() </span><span style="color:#6A737D;">// 获取之前的所有兄弟节点</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">getAllNextSiblings</span><span style="color:#24292E;">() </span><span style="color:#6A737D;">// 获取之后的所有兄弟节点</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">isXxx</span><span style="color:#24292E;">(opts) </span><span style="color:#6A737D;">// 判断当前节点是否是某个类型，可以传入属性和属性值进一步判断，比如path.isIdentifier({name: &#39;a&#39;})</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">assertXxx</span><span style="color:#24292E;">(opts) </span><span style="color:#6A737D;">// 同 isXxx，但是不返回布尔值，而是抛出异常</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">find</span><span style="color:#24292E;">(callback) </span><span style="color:#6A737D;">// 从当前节点到根节点来查找节点（包括当前节点），调用 callback（传入 path）来决定是否终止查找</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">findParent</span><span style="color:#24292E;">(callback) </span><span style="color:#6A737D;">// 从当前节点到根节点来查找节点（不包括当前节点），调用 callback（传入 path）来决定是否终止查找</span></span>
<span class="line"><span style="color:#24292E;">  </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">insertBefore</span><span style="color:#24292E;">(nodes) </span><span style="color:#6A737D;">// 在之前插入节点，可以是单个节点或者节点数组</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">insertAfter</span><span style="color:#24292E;">(nodes) </span><span style="color:#6A737D;">// 在之后插入节点，可以是单个节点或者节点数组</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">replaceWith</span><span style="color:#24292E;">(replacement) </span><span style="color:#6A737D;">// 用某个节点替换当前节点</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">replaceWithMultiple</span><span style="color:#24292E;">(nodes) </span><span style="color:#6A737D;">// 用多个节点替换当前节点</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">replaceWithSourceString</span><span style="color:#24292E;">(replacement) </span><span style="color:#6A737D;">// 解析源码成 AST，然后替换当前节点</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">remove</span><span style="color:#24292E;">() </span><span style="color:#6A737D;">// 删除当前节点</span></span>
<span class="line"><span style="color:#24292E;">  </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">traverse</span><span style="color:#24292E;">(visitor, state) </span><span style="color:#6A737D;">// 遍历当前节点的子节点，传入 visitor 和 state（state 是不同节点间传递数据的方式）</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">skip</span><span style="color:#24292E;">() </span><span style="color:#6A737D;">// 跳过当前节点的子节点的遍历</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">stop</span><span style="color:#24292E;">() </span><span style="color:#6A737D;">// 结束所有遍历</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h2 id="path-scope" tabindex="-1">path.scope <a class="header-anchor" href="#path-scope" aria-label="Permalink to &quot;path.scope&quot;">​</a></h2><p>path.scope 是当前节点的作用域，它提供了一些方法来操作当前作用域，比如获取当前作用域的变量、绑定变量、生成唯一标识符等等。scope 对象的属性和方法如下：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">scope.bindings </span><span style="color:#6A737D;">// 当前作用域内声明的所有变量</span></span>
<span class="line"><span style="color:#E1E4E8;">scope.block </span><span style="color:#6A737D;">// 生成作用域的 block，详见下文</span></span>
<span class="line"><span style="color:#E1E4E8;">scope.path </span><span style="color:#6A737D;">// 生成作用域的节点对应的 path</span></span>
<span class="line"><span style="color:#E1E4E8;">scope.references </span><span style="color:#6A737D;">// 所有 binding 的引用对应的 path，详见下文</span></span>
<span class="line"><span style="color:#E1E4E8;">scope.</span><span style="color:#B392F0;">dump</span><span style="color:#E1E4E8;">() </span><span style="color:#6A737D;">// 打印作用域链的所有 binding 到控制台</span></span>
<span class="line"><span style="color:#E1E4E8;">scope.parentBlock </span><span style="color:#6A737D;">// 父级作用域的 block</span></span>
<span class="line"><span style="color:#B392F0;">getAllBindings</span><span style="color:#E1E4E8;">() </span><span style="color:#6A737D;">// 从当前作用域到根作用域的所有 binding 的合并</span></span>
<span class="line"><span style="color:#B392F0;">getBinding</span><span style="color:#E1E4E8;">(name) </span><span style="color:#6A737D;">// 查找某个 binding，从当前作用域一直查找到根作用域</span></span>
<span class="line"><span style="color:#B392F0;">getOwnBinding</span><span style="color:#E1E4E8;">(name) </span><span style="color:#6A737D;">// 从当前作用域查找 binding</span></span>
<span class="line"><span style="color:#B392F0;">parentHasBinding</span><span style="color:#E1E4E8;">(name, noGlobals) </span><span style="color:#6A737D;">// 查找某个 binding，从父作用域查到根作用域，不包括当前作用域。可以通过 noGlobals 参数指定是否算上全局变量（比如console，不需要声明就可用），默认是 false</span></span>
<span class="line"><span style="color:#B392F0;">removeBinding</span><span style="color:#E1E4E8;">(name) </span><span style="color:#6A737D;">// 删除某个 binding</span></span>
<span class="line"><span style="color:#B392F0;">hasBinding</span><span style="color:#E1E4E8;">(name, noGlobals) </span><span style="color:#6A737D;">// 从当前作用域查找 binding，可以指定是否算上全局变量，默认是 false</span></span>
<span class="line"><span style="color:#B392F0;">moveBindingTo</span><span style="color:#E1E4E8;">(name, scope) </span><span style="color:#6A737D;">// 把当前作用域中的某个 binding 移动到其他作用域</span></span>
<span class="line"><span style="color:#B392F0;">generateUid</span><span style="color:#E1E4E8;">(name) </span><span style="color:#6A737D;">// 生成作用域内唯一的名字，根据 name 添加下划线，比如 name 为 a，会尝试生成 _a，如果被占用就会生成 __a，直到生成没有被使用的名字i</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">scope.bindings </span><span style="color:#6A737D;">// 当前作用域内声明的所有变量</span></span>
<span class="line"><span style="color:#24292E;">scope.block </span><span style="color:#6A737D;">// 生成作用域的 block，详见下文</span></span>
<span class="line"><span style="color:#24292E;">scope.path </span><span style="color:#6A737D;">// 生成作用域的节点对应的 path</span></span>
<span class="line"><span style="color:#24292E;">scope.references </span><span style="color:#6A737D;">// 所有 binding 的引用对应的 path，详见下文</span></span>
<span class="line"><span style="color:#24292E;">scope.</span><span style="color:#6F42C1;">dump</span><span style="color:#24292E;">() </span><span style="color:#6A737D;">// 打印作用域链的所有 binding 到控制台</span></span>
<span class="line"><span style="color:#24292E;">scope.parentBlock </span><span style="color:#6A737D;">// 父级作用域的 block</span></span>
<span class="line"><span style="color:#6F42C1;">getAllBindings</span><span style="color:#24292E;">() </span><span style="color:#6A737D;">// 从当前作用域到根作用域的所有 binding 的合并</span></span>
<span class="line"><span style="color:#6F42C1;">getBinding</span><span style="color:#24292E;">(name) </span><span style="color:#6A737D;">// 查找某个 binding，从当前作用域一直查找到根作用域</span></span>
<span class="line"><span style="color:#6F42C1;">getOwnBinding</span><span style="color:#24292E;">(name) </span><span style="color:#6A737D;">// 从当前作用域查找 binding</span></span>
<span class="line"><span style="color:#6F42C1;">parentHasBinding</span><span style="color:#24292E;">(name, noGlobals) </span><span style="color:#6A737D;">// 查找某个 binding，从父作用域查到根作用域，不包括当前作用域。可以通过 noGlobals 参数指定是否算上全局变量（比如console，不需要声明就可用），默认是 false</span></span>
<span class="line"><span style="color:#6F42C1;">removeBinding</span><span style="color:#24292E;">(name) </span><span style="color:#6A737D;">// 删除某个 binding</span></span>
<span class="line"><span style="color:#6F42C1;">hasBinding</span><span style="color:#24292E;">(name, noGlobals) </span><span style="color:#6A737D;">// 从当前作用域查找 binding，可以指定是否算上全局变量，默认是 false</span></span>
<span class="line"><span style="color:#6F42C1;">moveBindingTo</span><span style="color:#24292E;">(name, scope) </span><span style="color:#6A737D;">// 把当前作用域中的某个 binding 移动到其他作用域</span></span>
<span class="line"><span style="color:#6F42C1;">generateUid</span><span style="color:#24292E;">(name) </span><span style="color:#6A737D;">// 生成作用域内唯一的名字，根据 name 添加下划线，比如 name 为 a，会尝试生成 _a，如果被占用就会生成 __a，直到生成没有被使用的名字i</span></span></code></pre></div><p>path.scope.bindings 如下：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">bindings</span><span style="color:#E1E4E8;">: {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">a</span><span style="color:#E1E4E8;">: {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">constant</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">, </span><span style="color:#6A737D;">// 是否被修改过</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">constantViolations</span><span style="color:#E1E4E8;">: [], </span><span style="color:#6A737D;">// 所有修改过的语句的 path</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">identifier</span><span style="color:#E1E4E8;">: {</span><span style="color:#B392F0;">type</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">&#39;Identifier&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">...</span><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">kind</span><span style="color:#E1E4E8;">:</span><span style="color:#9ECBFF;">&#39;const&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#6A737D;">// 声明变量的形式</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">path</span><span style="color:#E1E4E8;">: {node,</span><span style="color:#F97583;">...</span><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">referenced</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 是否被引用</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">referencePaths</span><span style="color:#E1E4E8;">: [], </span><span style="color:#6A737D;">// 引用的语句对应的 path</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">references</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, </span><span style="color:#6A737D;">// 引用的数目</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">scope</span><span style="color:#E1E4E8;">: </span><span style="color:#F97583;">...</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">bindings</span><span style="color:#24292E;">: {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">a</span><span style="color:#24292E;">: {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">constant</span><span style="color:#24292E;">: </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">, </span><span style="color:#6A737D;">// 是否被修改过</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">constantViolations</span><span style="color:#24292E;">: [], </span><span style="color:#6A737D;">// 所有修改过的语句的 path</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">identifier</span><span style="color:#24292E;">: {</span><span style="color:#6F42C1;">type</span><span style="color:#24292E;">: </span><span style="color:#032F62;">&#39;Identifier&#39;</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">...</span><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">kind</span><span style="color:#24292E;">:</span><span style="color:#032F62;">&#39;const&#39;</span><span style="color:#24292E;">, </span><span style="color:#6A737D;">// 声明变量的形式</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">path</span><span style="color:#24292E;">: {node,</span><span style="color:#D73A49;">...</span><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">referenced</span><span style="color:#24292E;">: </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 是否被引用</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">referencePaths</span><span style="color:#24292E;">: [], </span><span style="color:#6A737D;">// 引用的语句对应的 path</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">references</span><span style="color:#24292E;">: </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, </span><span style="color:#6A737D;">// 引用的数目</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">scope</span><span style="color:#24292E;">: </span><span style="color:#D73A49;">...</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div>`,20),e=[o];function c(t,r,E,y,i,d){return n(),a("div",null,e)}const h=s(l,[["render",c]]);export{A as __pageData,h as default};
