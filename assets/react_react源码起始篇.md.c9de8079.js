import{_ as s,o as n,c as a,Q as l}from"./chunks/framework.b96c6c14.js";const p="/assets/container-root-fiber.9a7afa97.jpeg",A=JSON.parse('{"title":"React源码起始篇","description":"","frontmatter":{},"headers":[],"relativePath":"react/react源码起始篇.md","filePath":"react/react源码起始篇.md","lastUpdated":1698927986000}'),o={name:"react/react源码起始篇.md"},e=l(`<h1 id="react源码起始篇" tabindex="-1">React源码起始篇 <a class="header-anchor" href="#react源码起始篇" aria-label="Permalink to &quot;React源码起始篇&quot;">​</a></h1><h2 id="createroot" tabindex="-1">createRoot <a class="header-anchor" href="#createroot" aria-label="Permalink to &quot;createRoot&quot;">​</a></h2><p><code>React</code>中如果想使用<code>ConcurrentMode</code>，需要使用<code>createRoot</code>函数来创建应用：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">root</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> document.</span><span style="color:#B392F0;">getElementById</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;root&#39;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">ReactDOM.</span><span style="color:#B392F0;">createRoot</span><span style="color:#E1E4E8;">(root).</span><span style="color:#B392F0;">render</span><span style="color:#E1E4E8;">(&lt;</span><span style="color:#79B8FF;">App</span><span style="color:#E1E4E8;"> /&gt;)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">root</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> document.</span><span style="color:#6F42C1;">getElementById</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;root&#39;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">ReactDOM.</span><span style="color:#6F42C1;">createRoot</span><span style="color:#24292E;">(root).</span><span style="color:#6F42C1;">render</span><span style="color:#24292E;">(&lt;</span><span style="color:#005CC5;">App</span><span style="color:#24292E;"> /&gt;)</span></span></code></pre></div><p>在 <code>react-dom/src/client/ReactDomRoot.js</code>文件中找到<code>createRoot</code>定义：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">export</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">createRoot</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">container</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Container</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">options</span><span style="color:#F97583;">?:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">CreateRootOptions</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">RootType</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// ...</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 1. 创建完成了根节点，返回的是 FiberRoot，为 ConcurrentRoot 模式</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">root</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">createContainer</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">    container,</span></span>
<span class="line"><span style="color:#E1E4E8;">    ConcurrentRoot,</span></span>
<span class="line"><span style="color:#E1E4E8;">    hydrate,</span></span>
<span class="line"><span style="color:#E1E4E8;">    hydrationCallbacks,</span></span>
<span class="line"><span style="color:#E1E4E8;">    isStrictMode,</span></span>
<span class="line"><span style="color:#E1E4E8;">    concurrentUpdatesByDefaultOverride,</span></span>
<span class="line"><span style="color:#E1E4E8;">  );</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 2. node 节点 和 rootFiber 的关系</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">//  container[&#39;__reactContainer$&#39; + randomKey] = root.current</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">markContainerAsRoot</span><span style="color:#E1E4E8;">(root.current, container);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">rootContainerElement</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span></span>
<span class="line"><span style="color:#E1E4E8;">    container.nodeType </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">COMMENT_NODE</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> container.parentNode </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> container;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 3. 在 container 上添加原生事件</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">listenToAllSupportedEvents</span><span style="color:#E1E4E8;">(rootContainerElement);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 实例化 root，root上挂载了 render, unmount 方法</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// this._internalRoot = internalRoot</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ReactDOMRoot</span><span style="color:#E1E4E8;">(root);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">export</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">createRoot</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">container</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Container</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">options</span><span style="color:#D73A49;">?:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">CreateRootOptions</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">)</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">RootType</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// ...</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 1. 创建完成了根节点，返回的是 FiberRoot，为 ConcurrentRoot 模式</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">root</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">createContainer</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">    container,</span></span>
<span class="line"><span style="color:#24292E;">    ConcurrentRoot,</span></span>
<span class="line"><span style="color:#24292E;">    hydrate,</span></span>
<span class="line"><span style="color:#24292E;">    hydrationCallbacks,</span></span>
<span class="line"><span style="color:#24292E;">    isStrictMode,</span></span>
<span class="line"><span style="color:#24292E;">    concurrentUpdatesByDefaultOverride,</span></span>
<span class="line"><span style="color:#24292E;">  );</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 2. node 节点 和 rootFiber 的关系</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">//  container[&#39;__reactContainer$&#39; + randomKey] = root.current</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">markContainerAsRoot</span><span style="color:#24292E;">(root.current, container);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">rootContainerElement</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span></span>
<span class="line"><span style="color:#24292E;">    container.nodeType </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">COMMENT_NODE</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> container.parentNode </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> container;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 3. 在 container 上添加原生事件</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">listenToAllSupportedEvents</span><span style="color:#24292E;">(rootContainerElement);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 实例化 root，root上挂载了 render, unmount 方法</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// this._internalRoot = internalRoot</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ReactDOMRoot</span><span style="color:#24292E;">(root);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p><code>createRoot</code>方法主要做了两件事情：</p><ol><li>根据<code>rootContainer</code>创建<code>FiberRoot</code>。</li><li>在<code>container</code>上添加原生事件。</li></ol><p><code>React</code>实现了一套自己的事件系统，几乎所有原生事件都绑定在<code>container</code>上，通过事件冒泡的方式捕捉具体的事件，详细的内容将在<code>React</code>事件系统章节讲解。这里主要讨论<code>createContainer</code>，找到<code>react-reconciler/src/ReactFiberRoot.new.js</code>文件中的<code>createFiberRoot</code>函数：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">export</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">createFiberRoot</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">containerInfo</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">any</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">tag</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">RootTag</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">hydrate</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">boolean</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">hydrationCallbacks</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">SuspenseHydrationCallbacks</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">isStrictMode</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">boolean</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">concurrentUpdatesByDefaultOverride</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">boolean</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">FiberRoot</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 1. 创建Fiber root</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">root</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">FiberRoot</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">FiberRootNode</span><span style="color:#E1E4E8;">(containerInfo, tag, hydrate): any);</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 2. 创建一个 tag 为 HostRoot 的 RootFiber</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 并且带上当前的模式（tag就是对应的模式，当然还会进行更一层的判断）</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">uninitializedFiber</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">createHostRootFiber</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">    tag,</span></span>
<span class="line"><span style="color:#E1E4E8;">    isStrictMode,</span></span>
<span class="line"><span style="color:#E1E4E8;">    concurrentUpdatesByDefaultOverride,</span></span>
<span class="line"><span style="color:#E1E4E8;">  );</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 3. 建立 fiberRoot 和 rootFiber的关系</span></span>
<span class="line"><span style="color:#E1E4E8;">  root.current </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> uninitializedFiber;</span></span>
<span class="line"><span style="color:#E1E4E8;">  uninitializedFiber.stateNode </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> root;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">initialState</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    element: </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  };</span></span>
<span class="line"><span style="color:#E1E4E8;">  uninitializedFiber.memoizedState </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> initialState;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 4. 初始化 update queue</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">initializeUpdateQueue</span><span style="color:#E1E4E8;">(uninitializedFiber);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> root;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">export</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">createFiberRoot</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">containerInfo</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">any</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">tag</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">RootTag</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">hydrate</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">boolean</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">hydrationCallbacks</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">SuspenseHydrationCallbacks</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">isStrictMode</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">boolean</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">concurrentUpdatesByDefaultOverride</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">boolean</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">)</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">FiberRoot</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 1. 创建Fiber root</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">root</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">FiberRoot</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">FiberRootNode</span><span style="color:#24292E;">(containerInfo, tag, hydrate): any);</span></span>
<span class="line"><span style="color:#24292E;">  </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 2. 创建一个 tag 为 HostRoot 的 RootFiber</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 并且带上当前的模式（tag就是对应的模式，当然还会进行更一层的判断）</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">uninitializedFiber</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">createHostRootFiber</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">    tag,</span></span>
<span class="line"><span style="color:#24292E;">    isStrictMode,</span></span>
<span class="line"><span style="color:#24292E;">    concurrentUpdatesByDefaultOverride,</span></span>
<span class="line"><span style="color:#24292E;">  );</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 3. 建立 fiberRoot 和 rootFiber的关系</span></span>
<span class="line"><span style="color:#24292E;">  root.current </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> uninitializedFiber;</span></span>
<span class="line"><span style="color:#24292E;">  uninitializedFiber.stateNode </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> root;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">initialState</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    element: </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  };</span></span>
<span class="line"><span style="color:#24292E;">  uninitializedFiber.memoizedState </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> initialState;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 4. 初始化 update queue</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">initializeUpdateQueue</span><span style="color:#24292E;">(uninitializedFiber);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> root;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p><code>createContainer</code>调用的是<code>createFiberRoot</code>函数，主要作用为：</p><ol><li>根据<code>container</code>创建<code>FiberRoot</code>。</li><li>创建一个<code>tag</code>为<code>HostRoot</code>的<code>RootFiber</code>。</li><li>建立<code>FiberRoot</code>和<code>RootFiber</code>的联系。</li></ol><p>整个过程创建完成后，会形成如下的结构：</p><p><img src="`+p+`" alt="img"></p><p>其中多出来的<code>workInProgressFiber</code>是后续<code>render</code>时才会创建。</p><p>执行完<code>createRoot</code>函数后，我们已经能够获取到<code>ReactDomRoot</code>的实例了，接下来就是执行<code>render</code>函数了。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">ReactDOM.</span><span style="color:#B392F0;">createRoot</span><span style="color:#E1E4E8;">(root).</span><span style="color:#B392F0;">render</span><span style="color:#E1E4E8;">(&lt;</span><span style="color:#79B8FF;">App</span><span style="color:#E1E4E8;"> /&gt;)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">ReactDOM.</span><span style="color:#6F42C1;">createRoot</span><span style="color:#24292E;">(root).</span><span style="color:#6F42C1;">render</span><span style="color:#24292E;">(&lt;</span><span style="color:#005CC5;">App</span><span style="color:#24292E;"> /&gt;)</span></span></code></pre></div><h2 id="jsx" tabindex="-1">jsx <a class="header-anchor" href="#jsx" aria-label="Permalink to &quot;jsx&quot;">​</a></h2><p>在<code>React</code>中，<code>JSX</code>语法在编译时会被<code>Babel</code>编译为<code>React.createElement</code>方法。这就是为什么在每个使用了<code>jsx</code>语法的文件中，必须显示的引入<code>React</code>的原因，否则在运行的时候会无法找到<code>React.createElement</code>方法。</p><p><code>JSX</code>并不是只能被编译为<code>React.createElement</code>方法，你可以通过<a href="https://babeljs.io/docs/en/babel-plugin-transform-react-jsx" target="_blank" rel="noreferrer">@babel/plugin-transform-react-jsx(opens new window)</a>插件显式告诉<code>Babel</code>编译时需要将<code>JSX</code>编译为其他函数的调用（默认为<code>React.createElement</code>）。</p><h4 id="标签名为小写时" tabindex="-1">标签名为小写时 <a class="header-anchor" href="#标签名为小写时" aria-label="Permalink to &quot;标签名为小写时&quot;">​</a></h4><p><code>JSX</code>编译时只要分为两种情况，一种是标签名为小写时，如：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">className</span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&quot;normal-tag&quot;</span><span style="color:#E1E4E8;">&gt;content&lt;/</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">div</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">className</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;normal-tag&quot;</span><span style="color:#24292E;">&gt;content&lt;/</span><span style="color:#22863A;">div</span><span style="color:#24292E;">&gt;</span></span></code></pre></div><p>会被编译成：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">React.</span><span style="color:#B392F0;">createElement</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&quot;div&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  {</span></span>
<span class="line"><span style="color:#E1E4E8;">    className: </span><span style="color:#9ECBFF;">&quot;normal-tag&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;">  },</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&quot;content&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;">);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">React.</span><span style="color:#6F42C1;">createElement</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&quot;div&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  {</span></span>
<span class="line"><span style="color:#24292E;">    className: </span><span style="color:#032F62;">&quot;normal-tag&quot;</span></span>
<span class="line"><span style="color:#24292E;">  },</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&quot;content&quot;</span></span>
<span class="line"><span style="color:#24292E;">);</span></span></code></pre></div><p><strong>注意，此时第一个参数为字符串形式。</strong></p><h4 id="标签名为大写时" tabindex="-1">标签名为大写时 <a class="header-anchor" href="#标签名为大写时" aria-label="Permalink to &quot;标签名为大写时&quot;">​</a></h4><p>例如编译函数式组件时：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">App</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">className</span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&quot;function-component&quot;</span><span style="color:#E1E4E8;">&gt;content&lt;/</span><span style="color:#79B8FF;">App</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#005CC5;">App</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">className</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;function-component&quot;</span><span style="color:#24292E;">&gt;content&lt;/</span><span style="color:#005CC5;">App</span><span style="color:#24292E;">&gt;</span></span></code></pre></div><p>会被编译为：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">React.</span><span style="color:#B392F0;">createElement</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">  App,</span></span>
<span class="line"><span style="color:#E1E4E8;">  {</span></span>
<span class="line"><span style="color:#E1E4E8;">    className: </span><span style="color:#9ECBFF;">&quot;function-component&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;">  },</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&quot;content&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;">);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">React.</span><span style="color:#6F42C1;">createElement</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">  App,</span></span>
<span class="line"><span style="color:#24292E;">  {</span></span>
<span class="line"><span style="color:#24292E;">    className: </span><span style="color:#032F62;">&quot;function-component&quot;</span></span>
<span class="line"><span style="color:#24292E;">  },</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&quot;content&quot;</span></span>
<span class="line"><span style="color:#24292E;">);</span></span></code></pre></div><p><strong>注意此时第一个参数为变量，这一点尤为重要，因为函数式组件，类组件，lazy组件等组件的渲染过程都与这个变量相关。</strong></p><p><code>jsx</code>的编译结果可以通过<a href="https://babeljs.io/repl#?browsers=defaults%2C%20not%20ie%2011%2C%20not%20ie_mob%2011&amp;build=&amp;builtIns=false&amp;corejs=3.6&amp;spec=false&amp;loose=false&amp;code_lz=DwQQDmAEDGA2CGBnRA5eBbApgXgEQDsB7AJ3XlgFoAXeAc1wD5pD8rNXgB6cMBoA&amp;debug=false&amp;forceAllTransforms=false&amp;shippedProposals=false&amp;circleciRepo=&amp;evaluate=true&amp;fileSize=false&amp;timeTravel=false&amp;sourceType=module&amp;lineWrap=true&amp;presets=env%2Creact&amp;prettier=true&amp;targets=&amp;version=7.15.6&amp;externalPlugins=&amp;assumptions=%7B%7D" target="_blank" rel="noreferrer">这里</a>进行预览调试。</p><h2 id="createelement" tabindex="-1">createElement <a class="header-anchor" href="#createelement" aria-label="Permalink to &quot;createElement&quot;">​</a></h2><p><code>JSX</code>编译后就会调用<code>createElement</code>方法了，该方法是在<code>React/src/ReactElement.js</code>文件中定义：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">export</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">createElement</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">type</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">config</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">children</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> propName;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">props</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> key </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> ref </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> self </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> source </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 1. 处理 props</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (config </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 为了简化代码，部分代码已删除</span></span>
<span class="line"><span style="color:#E1E4E8;">    ref </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> config.ref;</span></span>
<span class="line"><span style="color:#E1E4E8;">    key </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;&#39;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> config.key;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (propName </span><span style="color:#F97583;">in</span><span style="color:#E1E4E8;"> config) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      props[propName] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> config[propName];</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 2. 处理 children，如果 children 长度大于1，形成数组形式</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">childrenLength</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">arguments</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (childrenLength </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    props.children </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> children;</span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (childrenLength </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">childArray</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Array</span><span style="color:#E1E4E8;">(childrenLength);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> childrenLength;i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      childArray[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">arguments</span><span style="color:#E1E4E8;">[i </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">];</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    props.children </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> childArray;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 3. 处理 default props</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (type </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> type.defaultProps) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">defaultProps</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> type.defaultProps;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (propName </span><span style="color:#F97583;">in</span><span style="color:#E1E4E8;"> defaultProps) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (props[propName] </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">undefined</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        props[propName] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> defaultProps[propName];</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ReactElement</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">    type,</span></span>
<span class="line"><span style="color:#E1E4E8;">    key,</span></span>
<span class="line"><span style="color:#E1E4E8;">    ref,</span></span>
<span class="line"><span style="color:#E1E4E8;">    self,</span></span>
<span class="line"><span style="color:#E1E4E8;">    source,</span></span>
<span class="line"><span style="color:#E1E4E8;">    ReactCurrentOwner.current,</span></span>
<span class="line"><span style="color:#E1E4E8;">    props,</span></span>
<span class="line"><span style="color:#E1E4E8;">  );</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">export</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">createElement</span><span style="color:#24292E;">(</span><span style="color:#E36209;">type</span><span style="color:#24292E;">, </span><span style="color:#E36209;">config</span><span style="color:#24292E;">, </span><span style="color:#E36209;">children</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> propName;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">props</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> key </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> ref </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> self </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> source </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 1. 处理 props</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (config </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 为了简化代码，部分代码已删除</span></span>
<span class="line"><span style="color:#24292E;">    ref </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> config.ref;</span></span>
<span class="line"><span style="color:#24292E;">    key </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;&#39;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> config.key;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (propName </span><span style="color:#D73A49;">in</span><span style="color:#24292E;"> config) {</span></span>
<span class="line"><span style="color:#24292E;">      props[propName] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> config[propName];</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 2. 处理 children，如果 children 长度大于1，形成数组形式</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">childrenLength</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">arguments</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">length</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (childrenLength </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    props.children </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> children;</span></span>
<span class="line"><span style="color:#24292E;">  } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (childrenLength </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">childArray</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Array</span><span style="color:#24292E;">(childrenLength);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> childrenLength;i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      childArray[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">arguments</span><span style="color:#24292E;">[i </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">];</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    props.children </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> childArray;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 3. 处理 default props</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (type </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> type.defaultProps) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">defaultProps</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> type.defaultProps;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (propName </span><span style="color:#D73A49;">in</span><span style="color:#24292E;"> defaultProps) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (props[propName] </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">undefined</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        props[propName] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> defaultProps[propName];</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ReactElement</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">    type,</span></span>
<span class="line"><span style="color:#24292E;">    key,</span></span>
<span class="line"><span style="color:#24292E;">    ref,</span></span>
<span class="line"><span style="color:#24292E;">    self,</span></span>
<span class="line"><span style="color:#24292E;">    source,</span></span>
<span class="line"><span style="color:#24292E;">    ReactCurrentOwner.current,</span></span>
<span class="line"><span style="color:#24292E;">    props,</span></span>
<span class="line"><span style="color:#24292E;">  );</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p><code>type</code>表示的是<code>jsx</code>编译后的第一个参数，可能为普通字符串，也可能是一个变量。第二个参数<code>config</code>则是编译后节点上的属性。第三个及之后的参数表示该节点的<code>children</code>节点，如果子节点数目大于1，转换为数组形式。最终，经过<code>props,children</code>的处理后，会返回一个<code>ReactElement</code>对象。</p><h2 id="render" tabindex="-1">render <a class="header-anchor" href="#render" aria-label="Permalink to &quot;render&quot;">​</a></h2><p>接下来是正式的<code>render</code>阶段。找到<code>ReactDOMRoot.js</code>文件：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#79B8FF;">ReactDOMRoot</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">prototype</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">render</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">children</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ReactNodeList</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">void</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">root</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">._internalRoot;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">updateContainer</span><span style="color:#E1E4E8;">(children, root, </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#005CC5;">ReactDOMRoot</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">prototype</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">render</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> (</span><span style="color:#E36209;">children</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ReactNodeList</span><span style="color:#24292E;">)</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">void</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">root</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">._internalRoot;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">updateContainer</span><span style="color:#24292E;">(children, root, </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">};</span></span></code></pre></div><p><code>render</code>函数很简单，第一个是找到<code>FiberRoot</code>，然后调用<code>updateContainer</code>方法处理传入的<code>children</code>（也就是<code>&lt;App/&gt;</code>编译后对应的<code>ReactElement</code>节点）。</p><h2 id="updatecontainer" tabindex="-1">updateContainer <a class="header-anchor" href="#updatecontainer" aria-label="Permalink to &quot;updateContainer&quot;">​</a></h2><p>在<code>react-reconciler/src/ReactFiberReconciler.new.js</code>文件中：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">export</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">updateContainer</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">element</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ReactNodeList</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">container</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">OpaqueRoot</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">parentComponent</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">?</span><span style="color:#B392F0;">React$Component</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">any</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">any</span><span style="color:#E1E4E8;">&gt;,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">callback</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">?</span><span style="color:#B392F0;">Function</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Lane</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 1. 拿到 RootFiber</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">current</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> container.current;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 2. 获取 current time</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">eventTime</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">requestEventTime</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 3. 获取对应的 lane</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 第一次进来，concurrentMode，返回的 lane 为 DefaultLane</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">lane</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">requestUpdateLane</span><span style="color:#E1E4E8;">(current);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 4. 根据 时间 + 优先级 创建一个更新对象</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">update</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">createUpdate</span><span style="color:#E1E4E8;">(eventTime, lane);</span></span>
<span class="line"><span style="color:#E1E4E8;">  update.payload </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> { element };</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 如果传了 callback，将 callback 放入到 update 中</span></span>
<span class="line"><span style="color:#E1E4E8;">  callback </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> callback </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">undefined</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> callback;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (callback </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    update.callback </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> callback;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 5. update 建立成循环链表</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 并存放到 fiber.updateQueue.shared.pending 当中</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">enqueueUpdate</span><span style="color:#E1E4E8;">(current, update, lane);</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 6. 开始调度</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">root</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">scheduleUpdateOnFiber</span><span style="color:#E1E4E8;">(current, lane, eventTime);</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (root </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">entangleTransitions</span><span style="color:#E1E4E8;">(root, current, lane);</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> lane;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">export</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">updateContainer</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">element</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ReactNodeList</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">container</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">OpaqueRoot</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">parentComponent</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">?</span><span style="color:#6F42C1;">React$Component</span><span style="color:#24292E;">&lt;</span><span style="color:#005CC5;">any</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">any</span><span style="color:#24292E;">&gt;,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">callback</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">?</span><span style="color:#6F42C1;">Function</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">)</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Lane</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 1. 拿到 RootFiber</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">current</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> container.current;</span></span>
<span class="line"><span style="color:#24292E;">  </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 2. 获取 current time</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">eventTime</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">requestEventTime</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">  </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 3. 获取对应的 lane</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 第一次进来，concurrentMode，返回的 lane 为 DefaultLane</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">lane</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">requestUpdateLane</span><span style="color:#24292E;">(current);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 4. 根据 时间 + 优先级 创建一个更新对象</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">update</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">createUpdate</span><span style="color:#24292E;">(eventTime, lane);</span></span>
<span class="line"><span style="color:#24292E;">  update.payload </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> { element };</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 如果传了 callback，将 callback 放入到 update 中</span></span>
<span class="line"><span style="color:#24292E;">  callback </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> callback </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">undefined</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> callback;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (callback </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    update.callback </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> callback;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 5. update 建立成循环链表</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 并存放到 fiber.updateQueue.shared.pending 当中</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">enqueueUpdate</span><span style="color:#24292E;">(current, update, lane);</span></span>
<span class="line"><span style="color:#24292E;">  </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 6. 开始调度</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">root</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">scheduleUpdateOnFiber</span><span style="color:#24292E;">(current, lane, eventTime);</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (root </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">entangleTransitions</span><span style="color:#24292E;">(root, current, lane);</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> lane;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>第二步中，<code>requestEventTime</code>获取当前的时间，通常使用<code>preformance.now()</code>获取，用于表示该任务执行的起始时间。该时间会在优先级调度中用到，用于判断任务是否过期。</p><p>第三步中，<code>requestUpdateLane</code>获取本次更新的<code>lane</code>，不同的<code>lane</code>对应于不同的优先级。具体<code>lane</code>的描述在<code>lane</code>模型章节中提到。</p><p>第四步和第五步主要是创建一个<code>update</code>，然后将该<code>update</code>放到<code>updateQueue</code>中，用于表示本次更新的内容。</p><p>第六步就要开始正式的调度过程，也就是正式的任务调度和渲染环节。<code>class</code>组件中的<code>setState/forceUpdate</code>方法最后都会执行该函数进行调度，因此十分重要。</p><h2 id="scheduleupdateonfiber" tabindex="-1">scheduleUpdateOnFiber <a class="header-anchor" href="#scheduleupdateonfiber" aria-label="Permalink to &quot;scheduleUpdateOnFiber&quot;">​</a></h2><p>找到<code>react-reconciler/src/ReactFiberWorkLoop.new.js</code>文件：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">export</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">scheduleUpdateOnFiber</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">fiber</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Fiber</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">lane</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Lane</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">eventTime</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">FiberRoot</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">checkForNestedUpdates</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">warnAboutRenderPhaseUpdatesInDEV</span><span style="color:#E1E4E8;">(fiber);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 从 fiber 一直向上合并 lanes，更改了 lanes , childLanes</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 当向上寻找fiber 最终找到 rootFiber 时，会返回对应的 fiberRoot</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">root</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">markUpdateLaneFromFiberToRoot</span><span style="color:#E1E4E8;">(fiber, lane);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 更新 fiber root 上 pendingLanes，加入当前 lane</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 计算 lane 所在位置（32条lane中的第几级），并将 eventTime 放到 eventTimes 里</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// eventTime 表示创建这个 update 的时间。也是 lane 对应的时间。</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">markRootUpdated</span><span style="color:#E1E4E8;">(root, lane, eventTime);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 开始调度任务</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">ensureRootIsScheduled</span><span style="color:#E1E4E8;">(root, eventTime);</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> root;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">export</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">scheduleUpdateOnFiber</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">fiber</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Fiber</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">lane</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Lane</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">eventTime</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">number</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">)</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">FiberRoot</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">checkForNestedUpdates</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">warnAboutRenderPhaseUpdatesInDEV</span><span style="color:#24292E;">(fiber);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 从 fiber 一直向上合并 lanes，更改了 lanes , childLanes</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 当向上寻找fiber 最终找到 rootFiber 时，会返回对应的 fiberRoot</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">root</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">markUpdateLaneFromFiberToRoot</span><span style="color:#24292E;">(fiber, lane);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 更新 fiber root 上 pendingLanes，加入当前 lane</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 计算 lane 所在位置（32条lane中的第几级），并将 eventTime 放到 eventTimes 里</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// eventTime 表示创建这个 update 的时间。也是 lane 对应的时间。</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">markRootUpdated</span><span style="color:#24292E;">(root, lane, eventTime);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 开始调度任务</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">ensureRootIsScheduled</span><span style="color:#24292E;">(root, eventTime);</span></span>
<span class="line"><span style="color:#24292E;">  </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> root;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>首先会向上递归更新每个<code>fiber</code>的<code>lanes</code>和<code>childLanes</code>，并返回<code>fiberRoot</code>。随后标记当前任务的时间，计算当前<code>lane</code>处于哪条”赛道“，并在对应赛道上记录下本次更新的起始时间：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">root.eventTimes[index] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> eventTime</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">root.eventTimes[index] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> eventTime</span></span></code></pre></div><p>最后调用<code>ensureRootIsScheduled</code>方法开始真正的调度过程。</p><h2 id="ensurerootisscheduled" tabindex="-1">ensureRootIsScheduled <a class="header-anchor" href="#ensurerootisscheduled" aria-label="Permalink to &quot;ensureRootIsScheduled&quot;">​</a></h2><p>还是在<code>ReactFiberWorkLoop.new.js</code>文件中：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ensureRootIsScheduled</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">root</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">FiberRoot</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">currentTime</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 1. root.callbackNode 是在每次调度完赋值的，也就是本函数的末尾</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 它代表当前的任务（scheduler中返回的任务）</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">existingCallbackNode</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> root.callbackNode;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 2. 递归 pendingLanes，如果 lane 过期了会加入到 expiredLanes 中</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 如果老任务一直被打断，但是老任务时间到了，就会将其置为过期，这样下次就可以以最高优先级进行更新了。</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">markStarvedLanesAsExpired</span><span style="color:#E1E4E8;">(root, currentTime);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 3. 根据优先级来判断下一个应该执行的 lane（选取优先级最高的 lane）</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nextLanes</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getNextLanes</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">    root,</span></span>
<span class="line"><span style="color:#E1E4E8;">    root </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> workInProgressRoot </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> workInProgressRootRenderLanes </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> NoLanes,</span></span>
<span class="line"><span style="color:#E1E4E8;">  );</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 4. 说明没有要执行的任务</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (nextLanes </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> NoLanes) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (existingCallbackNode </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 取消当前任务</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#B392F0;">cancelCallback</span><span style="color:#E1E4E8;">(existingCallbackNode);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    root.callbackNode </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    root.callbackPriority </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> NoLane;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 5. 获取 nextLanes 中的最高优先级</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">newCallbackPriority</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getHighestPriorityLane</span><span style="color:#E1E4E8;">(nextLanes);</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">// 当前执行任务的优先级</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">existingCallbackPriority</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> root.callbackPriority;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 如果与当前优先级没有变化，那么直接返回。</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 这就是为什么能实现批量更新的原理：</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 首先 setState 会进行 schedule，再下一次 setState 的时候，由于优先级相同，不会进行 schedule</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (existingCallbackPriority </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> newCallbackPriority) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 6. 优先级变化了，由于每次都是取的最高优先级，所以一定是优先级更高的任务进来了。</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 那么取消上一个任务</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (existingCallbackNode </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// cancelCallback 主要操作就是将 任务的 callback 置空了。</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">cancelCallback</span><span style="color:#E1E4E8;">(existingCallbackNode);</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 7. 调度</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> newCallbackNode;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 如果优先级为同步优先级</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (newCallbackPriority </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> SyncLane) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 17版本为 concurrentMode 模式。搜集需要同步执行的函数</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">scheduleSyncCallback</span><span style="color:#E1E4E8;">(performSyncWorkOnRoot.</span><span style="color:#B392F0;">bind</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">, root));</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (supportsMicrotasks) {</span></span>
<span class="line"><span style="color:#E1E4E8;">       </span><span style="color:#6A737D;">// 如果支持微任务，那么用微任务执行 flushSyncCallbacks</span></span>
<span class="line"><span style="color:#E1E4E8;">       </span><span style="color:#B392F0;">scheduleMicrotask</span><span style="color:#E1E4E8;">(flushSyncCallbacks);</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#B392F0;">scheduleCallback</span><span style="color:#E1E4E8;">(ImmediateSchedulerPriority, flushSyncCallbacks);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    newCallbackNode </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 如果优先级不为同步</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> schedulerPriorityLevel;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 将 lanes 转化为 scheduler 库的优先级</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">switch</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">lanesToEventPriority</span><span style="color:#E1E4E8;">(nextLanes)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> DiscreteEventPriority:</span></span>
<span class="line"><span style="color:#E1E4E8;">        schedulerPriorityLevel </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> ImmediateSchedulerPriority;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> ContinuousEventPriority:</span></span>
<span class="line"><span style="color:#E1E4E8;">        schedulerPriorityLevel </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> UserBlockingSchedulerPriority;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> DefaultEventPriority:</span></span>
<span class="line"><span style="color:#E1E4E8;">        schedulerPriorityLevel </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> NormalSchedulerPriority;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> IdleEventPriority:</span></span>
<span class="line"><span style="color:#E1E4E8;">        schedulerPriorityLevel </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> IdleSchedulerPriority;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">default</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">        schedulerPriorityLevel </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> NormalSchedulerPriority;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 调度过程。计算过期时间，推入到任务队列，执行任务队列，</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 执行 callback，并且封装成为一个任务，进行返回 =》 newCallbackNode</span></span>
<span class="line"><span style="color:#E1E4E8;">    newCallbackNode </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">scheduleCallback</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">      schedulerPriorityLevel,</span></span>
<span class="line"><span style="color:#E1E4E8;">      performConcurrentWorkOnRoot.</span><span style="color:#B392F0;">bind</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">, root),</span></span>
<span class="line"><span style="color:#E1E4E8;">    );</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 8. 进行赋值</span></span>
<span class="line"><span style="color:#E1E4E8;">  root.callbackPriority </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> newCallbackPriority;</span></span>
<span class="line"><span style="color:#E1E4E8;">  root.callbackNode </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> newCallbackNode;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ensureRootIsScheduled</span><span style="color:#24292E;">(</span><span style="color:#E36209;">root</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">FiberRoot</span><span style="color:#24292E;">, </span><span style="color:#E36209;">currentTime</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">number</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 1. root.callbackNode 是在每次调度完赋值的，也就是本函数的末尾</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 它代表当前的任务（scheduler中返回的任务）</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">existingCallbackNode</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> root.callbackNode;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 2. 递归 pendingLanes，如果 lane 过期了会加入到 expiredLanes 中</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 如果老任务一直被打断，但是老任务时间到了，就会将其置为过期，这样下次就可以以最高优先级进行更新了。</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">markStarvedLanesAsExpired</span><span style="color:#24292E;">(root, currentTime);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 3. 根据优先级来判断下一个应该执行的 lane（选取优先级最高的 lane）</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nextLanes</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getNextLanes</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">    root,</span></span>
<span class="line"><span style="color:#24292E;">    root </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> workInProgressRoot </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> workInProgressRootRenderLanes </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> NoLanes,</span></span>
<span class="line"><span style="color:#24292E;">  );</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 4. 说明没有要执行的任务</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (nextLanes </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> NoLanes) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (existingCallbackNode </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 取消当前任务</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6F42C1;">cancelCallback</span><span style="color:#24292E;">(existingCallbackNode);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    root.callbackNode </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    root.callbackPriority </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> NoLane;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 5. 获取 nextLanes 中的最高优先级</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">newCallbackPriority</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getHighestPriorityLane</span><span style="color:#24292E;">(nextLanes);</span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#6A737D;">// 当前执行任务的优先级</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">existingCallbackPriority</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> root.callbackPriority;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 如果与当前优先级没有变化，那么直接返回。</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 这就是为什么能实现批量更新的原理：</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 首先 setState 会进行 schedule，再下一次 setState 的时候，由于优先级相同，不会进行 schedule</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (existingCallbackPriority </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> newCallbackPriority) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 6. 优先级变化了，由于每次都是取的最高优先级，所以一定是优先级更高的任务进来了。</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 那么取消上一个任务</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (existingCallbackNode </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// cancelCallback 主要操作就是将 任务的 callback 置空了。</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">cancelCallback</span><span style="color:#24292E;">(existingCallbackNode);</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 7. 调度</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> newCallbackNode;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 如果优先级为同步优先级</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (newCallbackPriority </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> SyncLane) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 17版本为 concurrentMode 模式。搜集需要同步执行的函数</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">scheduleSyncCallback</span><span style="color:#24292E;">(performSyncWorkOnRoot.</span><span style="color:#6F42C1;">bind</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">null</span><span style="color:#24292E;">, root));</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (supportsMicrotasks) {</span></span>
<span class="line"><span style="color:#24292E;">       </span><span style="color:#6A737D;">// 如果支持微任务，那么用微任务执行 flushSyncCallbacks</span></span>
<span class="line"><span style="color:#24292E;">       </span><span style="color:#6F42C1;">scheduleMicrotask</span><span style="color:#24292E;">(flushSyncCallbacks);</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6F42C1;">scheduleCallback</span><span style="color:#24292E;">(ImmediateSchedulerPriority, flushSyncCallbacks);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    newCallbackNode </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如果优先级不为同步</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> schedulerPriorityLevel;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 将 lanes 转化为 scheduler 库的优先级</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">switch</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">lanesToEventPriority</span><span style="color:#24292E;">(nextLanes)) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> DiscreteEventPriority:</span></span>
<span class="line"><span style="color:#24292E;">        schedulerPriorityLevel </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> ImmediateSchedulerPriority;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> ContinuousEventPriority:</span></span>
<span class="line"><span style="color:#24292E;">        schedulerPriorityLevel </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> UserBlockingSchedulerPriority;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> DefaultEventPriority:</span></span>
<span class="line"><span style="color:#24292E;">        schedulerPriorityLevel </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> NormalSchedulerPriority;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> IdleEventPriority:</span></span>
<span class="line"><span style="color:#24292E;">        schedulerPriorityLevel </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> IdleSchedulerPriority;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">default</span><span style="color:#24292E;">:</span></span>
<span class="line"><span style="color:#24292E;">        schedulerPriorityLevel </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> NormalSchedulerPriority;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 调度过程。计算过期时间，推入到任务队列，执行任务队列，</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 执行 callback，并且封装成为一个任务，进行返回 =》 newCallbackNode</span></span>
<span class="line"><span style="color:#24292E;">    newCallbackNode </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">scheduleCallback</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">      schedulerPriorityLevel,</span></span>
<span class="line"><span style="color:#24292E;">      performConcurrentWorkOnRoot.</span><span style="color:#6F42C1;">bind</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">null</span><span style="color:#24292E;">, root),</span></span>
<span class="line"><span style="color:#24292E;">    );</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 8. 进行赋值</span></span>
<span class="line"><span style="color:#24292E;">  root.callbackPriority </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> newCallbackPriority;</span></span>
<span class="line"><span style="color:#24292E;">  root.callbackNode </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> newCallbackNode;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这里涉及到”饥饿问题“以及任务被打断的过程。举个例子来讲，现在正在执行一个优先级为<code>A</code>的<code>A</code>更新任务，然后又进来了一个优先级为<code>B</code>的<code>B</code>任务，由于任务<code>B</code>的优先级高于<code>A</code>，那么<code>nextLanes</code>取的是任务<code>B</code>的优先级，因此会打断任务<code>A</code>，执行<code>cancelCallback</code>，然后开始任务<code>B</code>的调度<code>scheduleCallback</code>。如果下一次任务<code>C</code>进来又比任务<code>A</code>优先级高，导致任务<code>A</code>又没有被执行，并且任务<code>A</code>已经达到了预定的过期时间，这个时候就会导致<code>饥饿问题</code>。解决办法就是执行<code>markStarvedLanesAsExpired</code>方法，将任务<code>A</code>标记为过期，这样下一次它的执行优先级就为最高了，也就能够得到执行。</p><p>想要理解这个例子，需要先理解任务调度，优先级以及过期时间等概念，这些在调度章节会进行详细讲解。</p>`,59),c=[e];function t(r,E,y,i,d,F){return n(),a("div",null,c)}const C=s(o,[["render",t]]);export{A as __pageData,C as default};
