import{_ as s,o as a,c as o,Q as e}from"./chunks/framework.92ce8a2a.js";const u=JSON.parse('{"title":"哈希表/散列表","description":"","frontmatter":{},"headers":[],"relativePath":"data-structures/哈希表.md","filePath":"data-structures/哈希表.md","lastUpdated":1695640069000}'),n={name:"data-structures/哈希表.md"},l=e(`<h1 id="哈希表-散列表" tabindex="-1">哈希表/散列表 <a class="header-anchor" href="#哈希表-散列表" aria-label="Permalink to &quot;哈希表/散列表&quot;">​</a></h1><h2 id="简介" tabindex="-1">简介 <a class="header-anchor" href="#简介" aria-label="Permalink to &quot;简介&quot;">​</a></h2><p><strong>哈希表</strong>是一种以 &quot;key-value&quot; 形式存储数据的数据结构，其特点是能够通过<code>key</code>快速找到对应的<code>value</code>，时间复杂度为<code>O(1)</code>。</p><h2 id="实现方法" tabindex="-1">实现方法 <a class="header-anchor" href="#实现方法" aria-label="Permalink to &quot;实现方法&quot;">​</a></h2><p>给定哈希表一个长度<code>n</code>，计算出要存储数据的<code>key</code>的<code>code</code>值：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 计算 key 对应的 char code</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> hash </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Array.</span><span style="color:#B392F0;">from</span><span style="color:#E1E4E8;">(key).</span><span style="color:#B392F0;">reduce</span><span style="color:#E1E4E8;">((</span><span style="color:#FFAB70;">hashAccumulator</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">keySymbol</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> (hashAccumulator </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> keySymbol.</span><span style="color:#B392F0;">charCodeAt</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)), </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#6A737D;">// 取余</span></span>
<span class="line"><span style="color:#E1E4E8;">hash </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> hash </span><span style="color:#F97583;">%</span><span style="color:#E1E4E8;"> n</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 计算 key 对应的 char code</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> hash </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Array.</span><span style="color:#6F42C1;">from</span><span style="color:#24292E;">(key).</span><span style="color:#6F42C1;">reduce</span><span style="color:#24292E;">((</span><span style="color:#E36209;">hashAccumulator</span><span style="color:#24292E;">, </span><span style="color:#E36209;">keySymbol</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> (hashAccumulator </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> keySymbol.</span><span style="color:#6F42C1;">charCodeAt</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)), </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#6A737D;">// 取余</span></span>
<span class="line"><span style="color:#24292E;">hash </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> hash </span><span style="color:#D73A49;">%</span><span style="color:#24292E;"> n</span></span></code></pre></div><p>然后在计算出的<code>hash</code>位置，存放<code>value</code>值。下次查找时，计算出<code>hash</code>即可快速找到存放在这里的<code>value</code>值了。</p><p>由于键值是取余得来的，为了尽量避免<code>key</code>算出来的<code>hash</code>重复度较高，一般情况下哈希表的长度都是取比较合适的质数。</p><h2 id="哈希冲突" tabindex="-1">哈希冲突 <a class="header-anchor" href="#哈希冲突" aria-label="Permalink to &quot;哈希冲突&quot;">​</a></h2><p>由于可能存在多个不同的<code>key</code>最后计算出来的<code>code</code>值相同，这就造成了<strong>哈希冲突</strong>，一般解决哈希冲突有两种方法：<strong>开链法</strong>和<strong>线性探索法</strong>。</p><p><strong>开链法</strong>的实现原理是将多个相同<code>code</code>值的元素用链表的形式添加。这样每次通过计算出的<code>code</code>可以找出对应的链表，这个链表里存放着所有相关的元素，然后通过链表进行查找，最终通过对比当前要查找的<code>key</code>和链表里存放的<code>key</code>来找到对应的<code>value</code>。</p><p><strong>线性探索法</strong>是如果存放元素时，计算出的<code>code</code>位置已被占用，那么会寻找下一个位置。如果下一个位置没有被占用，那么就将该元素存放与此。下次取的时候，也会依照这个线性关系去查找对应的<code>key</code>。</p><p>线性探索法一般适用于元素数目相较于哈希表长度比较小的情况，开链法则相反。</p>`,13),p=[l];function c(t,r,d,y,h,E){return a(),o("div",null,p)}const _=s(n,[["render",c]]);export{u as __pageData,_ as default};
