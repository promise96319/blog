import{_ as s,o as e,c as a,a as o}from"./app.9fd1379c.js";const C=JSON.parse('{"title":"哈希表/散列表","description":"","frontmatter":{},"headers":[{"level":2,"title":"简介","slug":"简介","link":"#简介","children":[]},{"level":2,"title":"实现方法","slug":"实现方法","link":"#实现方法","children":[]},{"level":2,"title":"哈希冲突","slug":"哈希冲突","link":"#哈希冲突","children":[]}],"relativePath":"data-structures/哈希表.md","lastUpdated":1685031066000}'),n={name:"data-structures/哈希表.md"},c=o(`<h1 id="哈希表-散列表" tabindex="-1">哈希表/散列表 <a class="header-anchor" href="#哈希表-散列表" aria-hidden="true">#</a></h1><h2 id="简介" tabindex="-1">简介 <a class="header-anchor" href="#简介" aria-hidden="true">#</a></h2><p><strong>哈希表</strong>是一种以 &quot;key-value&quot; 形式存储数据的数据结构，其特点是能够通过<code>key</code>快速找到对应的<code>value</code>，时间复杂度为<code>O(1)</code>。</p><h2 id="实现方法" tabindex="-1">实现方法 <a class="header-anchor" href="#实现方法" aria-hidden="true">#</a></h2><p>给定哈希表一个长度<code>n</code>，计算出要存储数据的<code>key</code>的<code>code</code>值：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 计算 key 对应的 char code</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> hash </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Array</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">from</span><span style="color:#A6ACCD;">(key)</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">reduce</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">hashAccumulator</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">keySymbol</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> (hashAccumulator </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> keySymbol</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">charCodeAt</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;">))</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 取余</span></span>
<span class="line"><span style="color:#A6ACCD;">hash </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> hash </span><span style="color:#89DDFF;">%</span><span style="color:#A6ACCD;"> n</span></span>
<span class="line"></span></code></pre></div><p>然后在计算出的<code>hash</code>位置，存放<code>value</code>值。下次查找时，计算出<code>hash</code>即可快速找到存放在这里的<code>value</code>值了。</p><p>由于键值是取余得来的，为了尽量避免<code>key</code>算出来的<code>hash</code>重复度较高，一般情况下哈希表的长度都是取比较合适的质数。</p><h2 id="哈希冲突" tabindex="-1">哈希冲突 <a class="header-anchor" href="#哈希冲突" aria-hidden="true">#</a></h2><p>由于可能存在多个不同的<code>key</code>最后计算出来的<code>code</code>值相同，这就造成了<strong>哈希冲突</strong>，一般解决哈希冲突有两种方法：<strong>开链法</strong>和<strong>线性探索法</strong>。</p><p><strong>开链法</strong>的实现原理是将多个相同<code>code</code>值的元素用链表的形式添加。这样每次通过计算出的<code>code</code>可以找出对应的链表，这个链表里存放着所有相关的元素，然后通过链表进行查找，最终通过对比当前要查找的<code>key</code>和链表里存放的<code>key</code>来找到对应的<code>value</code>。</p><p><strong>线性探索法</strong>是如果存放元素时，计算出的<code>code</code>位置已被占用，那么会寻找下一个位置。如果下一个位置没有被占用，那么就将该元素存放与此。下次取的时候，也会依照这个线性关系去查找对应的<code>key</code>。</p><p>线性探索法一般适用于元素数目相较于哈希表长度比较小的情况，开链法则相反。</p>`,13),l=[c];function t(p,r,d,i,y,h){return e(),a("div",null,l)}const D=s(n,[["render",t]]);export{C as __pageData,D as default};
