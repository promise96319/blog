import{_ as s,o as n,c as a,Q as l}from"./chunks/framework.c610f10c.js";const p="/assets/fiber-structure.cb228ac9.png",o="/assets/fiber-double-cache.b570d550.png",b=JSON.parse('{"title":"Fiber","description":"","frontmatter":{},"headers":[],"relativePath":"react/Fiber.md","filePath":"react/Fiber.md","lastUpdated":1695631559000}'),e={name:"react/Fiber.md"},c=l(`<h1 id="fiber" tabindex="-1">Fiber <a class="header-anchor" href="#fiber" aria-label="Permalink to &quot;Fiber&quot;">​</a></h1><h2 id="起源" tabindex="-1">起源 <a class="header-anchor" href="#起源" aria-label="Permalink to &quot;起源&quot;">​</a></h2><p>在<code>React15</code>及以前的版本中，<code>React</code>采用递归的方式创建虚拟<code>DOM</code>，这个递归过程是不能中断的。如果组件树的层级很深，需要耗费大量时间创建递归创建<code>DOM</code>，那么就会阻塞线程，导致界面卡顿。</p><p>为了解决这个问题，<code>React16</code>引入了<code>Fiber</code>，重写了底层架构，将<code>React</code>的更新改为了<strong>异步可中断的更新</strong>。</p><h2 id="结构" tabindex="-1">结构 <a class="header-anchor" href="#结构" aria-label="Permalink to &quot;结构&quot;">​</a></h2><p>在 <code>react-reconciler/src/ReactFiber.new.js</code>中，定义了 <code>Fiber</code>的结构：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark has-diff vp-code-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">FiberNode</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">tag</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">WorkTag</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">pendingProps</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">mixed</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">key</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">string</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FFAB70;">mode</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">TypeOfMode</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// ====== 节点相关 =====</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// react 中的一套自己定义的标签</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.tag </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> tag;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 节点的 key 值</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.key </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> key;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// jsx 解析出来的标签的类型，可以为 字符串，对象等形式。</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.elementType </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 大部分情况下与 elementType 相同，但是有时候会被处理为其他值。</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.type </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 对于 普通标签，如 div，存储着对应的真实节点</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 对于 class 组件，存储着对应的 实例</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 对于 RootFiber，指向的是 FiberRoot</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.stateNode </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// ====== fiber 结构相关 =====</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 指向父fiber</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.return </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 指向子fiber</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.child </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 指向后一个兄弟fiber</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.sibling </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// fiber 的index，用于 diff 算法对比是否需要移动</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.index </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// ref</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.ref </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// ====== 状态相关 =====</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 新的 props</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.pendingProps </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> pendingProps;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 老的 props</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.memoizedProps </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 更新队列，保存着所有update，可以通过该队列来改变 state 等</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 注意：不同类型的节点，他们的更新队列存储的内容可能不一致</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.updateQueue </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 老 state</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.memoizedState </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 使用了 React.createContext 的 context 时，会将 context 记录下来。</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.dependencies </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 当前 react 模式，react18 将默认采用 ConcurrentMode</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.mode </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> mode;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// ====== effect 副作用 =====</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 当前 fiber 对应的操作</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.flags </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> NoFlags;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 子fiber 对应的操作</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.subtreeFlags </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> NoFlags;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 存储哪些 老fiber 下的 子fiber 需要删除</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.deletions </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// ====== 调度相关 =====</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 当前 fiber 操作优先级</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.lanes </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> NoLanes;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 子fiber 操作优先级</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.childLanes </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> NoLanes;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 指向对应的另一个fiber，构成双缓存结构</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.alternate </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light has-diff vp-code-light"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">FiberNode</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">tag</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">WorkTag</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">pendingProps</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">mixed</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">key</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">string</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#E36209;">mode</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">TypeOfMode</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// ====== 节点相关 =====</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// react 中的一套自己定义的标签</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.tag </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> tag;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 节点的 key 值</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.key </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> key;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// jsx 解析出来的标签的类型，可以为 字符串，对象等形式。</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.elementType </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 大部分情况下与 elementType 相同，但是有时候会被处理为其他值。</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.type </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 对于 普通标签，如 div，存储着对应的真实节点</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 对于 class 组件，存储着对应的 实例</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 对于 RootFiber，指向的是 FiberRoot</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.stateNode </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// ====== fiber 结构相关 =====</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 指向父fiber</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.return </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 指向子fiber</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.child </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 指向后一个兄弟fiber</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.sibling </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// fiber 的index，用于 diff 算法对比是否需要移动</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.index </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// ref</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.ref </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// ====== 状态相关 =====</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 新的 props</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.pendingProps </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> pendingProps;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 老的 props</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.memoizedProps </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 更新队列，保存着所有update，可以通过该队列来改变 state 等</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 注意：不同类型的节点，他们的更新队列存储的内容可能不一致</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.updateQueue </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 老 state</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.memoizedState </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 使用了 React.createContext 的 context 时，会将 context 记录下来。</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.dependencies </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 当前 react 模式，react18 将默认采用 ConcurrentMode</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.mode </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> mode;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// ====== effect 副作用 =====</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 当前 fiber 对应的操作</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.flags </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> NoFlags;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 子fiber 对应的操作</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.subtreeFlags </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> NoFlags;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 存储哪些 老fiber 下的 子fiber 需要删除</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.deletions </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// ====== 调度相关 =====</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 当前 fiber 操作优先级</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.lanes </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> NoLanes;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 子fiber 操作优先级</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.childLanes </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> NoLanes;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 指向对应的另一个fiber，构成双缓存结构</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.alternate </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h2 id="fiber树" tabindex="-1">Fiber树 <a class="header-anchor" href="#fiber树" aria-label="Permalink to &quot;Fiber树&quot;">​</a></h2><p>每一个节点对应一个 <code>ReactElement</code>，每一个<code>ReactElement</code>对应一个 <code>Fiber</code>。根据节点所在的具体位置，可以通过<code>Fiber</code>的<code>return/child/sibling</code>三个属性将所有的<code>Fiber</code>构建成一颗<code>Fiber</code>树。</p><p><img src="`+p+`" alt="img"></p><h2 id="双缓存" tabindex="-1">双缓存 <a class="header-anchor" href="#双缓存" aria-label="Permalink to &quot;双缓存&quot;">​</a></h2><p>在<code>React</code>中最多会同时存在两颗<code>Fiber</code>树，当前屏幕中已经显示的<code>Fiber</code>树在<code>React</code>源码中通常以变量<code>current</code>表示。当界面更新时，会在内存中构建另一颗<code>Fiber</code>树，在源码中以<code>workInProgress</code>表示。它们之间可以通过<code>alternate</code>变量来访问。具体代码在<code>react-reconciler/src/ReactFiber.new.js</code>的<code>createWorkInProgress</code>中：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">workInProgress.alternate </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> current</span></span>
<span class="line"><span style="color:#E1E4E8;">current.alternate </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> workInProgress</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">workInProgress.alternate </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> current</span></span>
<span class="line"><span style="color:#24292E;">current.alternate </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> workInProgress</span></span></code></pre></div><p>构建完成后的双缓存结构具体如下：</p><p><img src="`+o+'" alt="img"></p><p>该结构在<code>reconcile</code>阶段有着非常重要的作用，后续会在<code>beginWork</code>和<code>completeWork</code>中会提到具体的执行过程。</p><h2 id="资料" tabindex="-1">资料 <a class="header-anchor" href="#资料" aria-label="Permalink to &quot;资料&quot;">​</a></h2><ul><li><p><a href="https://www.bilibili.com/video/BV1it411p7v6?from=search&amp;seid=3508901752524570226" target="_blank" rel="noreferrer">fiber 介绍动画视频</a></p></li><li><p><a href="https://indepth.dev/posts/1008/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react" target="_blank" rel="noreferrer">inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react</a></p></li><li><p><a href="https://react.iamkasong.com/process/doubleBuffer.html#%E4%BB%80%E4%B9%88%E6%98%AF-%E5%8F%8C%E7%BC%93%E5%AD%98" target="_blank" rel="noreferrer">Fiber 架构工作原理 - 卡颂</a></p></li></ul>',18),t=[c];function r(E,y,i,d,F,h){return n(),a("div",null,t)}const D=s(e,[["render",r]]);export{b as __pageData,D as default};
