import{_ as e,o as a,c as o,Q as c}from"./chunks/framework.b96c6c14.js";const r="/assets/add-sourcemap.693a5de8.png",_=JSON.parse('{"title":"Sourcemap 调试","description":"","frontmatter":{},"headers":[],"relativePath":"project/infra/sourcemap.md","filePath":"project/infra/sourcemap.md","lastUpdated":1698927918000}'),d={name:"project/infra/sourcemap.md"},p=c('<h1 id="sourcemap-调试" tabindex="-1">Sourcemap 调试 <a class="header-anchor" href="#sourcemap-调试" aria-label="Permalink to &quot;Sourcemap 调试&quot;">​</a></h1><h2 id="背景" tabindex="-1">背景 <a class="header-anchor" href="#背景" aria-label="Permalink to &quot;背景&quot;">​</a></h2><p>公司 4.0 项目中采用联邦模块的方式来是组织其他 <code>App</code> 项目，并且引入了 <code>Widget</code> 动态组件的概念。这种架构方式使得 <code>App/Widget</code> 能够独立开发，提高了可维护性和可扩展性，但同时也使得 <code>App/Widget</code> 之间的调试变得复杂。比如在 <code>App</code> 开发中发现 <code>Widget</code> 存在问题时，需要启动 <code>Widget</code> 项目，并且修改 <code>App</code> 中 <code>Widget</code> 的引用方式来调试，比较复杂。</p><h2 id="问题原因" tabindex="-1">问题原因 <a class="header-anchor" href="#问题原因" aria-label="Permalink to &quot;问题原因&quot;">​</a></h2><p>之所以存在上述问题，是因为在生成环境下通常不会生成 <code>sourcemap</code> 文件。因为 <code>sourcemap</code> 文件中包含了源码的信息，如果泄露出去，可能会产生一些安全问题。另外一方面加载 <code>sourcemap</code> 文件会增加网络请求，影响性能。</p><p>由于没有 <code>sourcemap</code> 文件，浏览器无法将编译后的代码映射到源码，因此无法在浏览器中调试源码。</p><h2 id="浏览器加载-sourcemap" tabindex="-1">浏览器加载 Sourcemap <a class="header-anchor" href="#浏览器加载-sourcemap" aria-label="Permalink to &quot;浏览器加载 Sourcemap&quot;">​</a></h2><p>浏览器加载 <code>sourcemap</code> 主要通过三种方式：</p><h3 id="sourcemappingurl-注释" tabindex="-1">sourceMappingURL 注释 <a class="header-anchor" href="#sourcemappingurl-注释" aria-label="Permalink to &quot;sourceMappingURL 注释&quot;">​</a></h3><p>在构建产物时，如果我们选择生成 <code>sourcemap</code> 文件，那么在生成的文件结尾都会有一个 <code>sourceMappingURL</code> 注释：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// # sourceMappingURL=button.js.map</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// # sourceMappingURL=button.js.map</span></span></code></pre></div><p>每次加载该文件时，浏览器会根据 <code>sourceMappingURL</code> 注释中的 <code>URL</code> 路径来加载相应的 <code>sourcemap</code> 文件。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>通过 <code>//# sourcemapURL</code> 可以直接指定源码地址。</p></div><h3 id="http-响应头-sourcemap" tabindex="-1">HTTP 响应头 SourceMap <a class="header-anchor" href="#http-响应头-sourcemap" aria-label="Permalink to &quot;HTTP 响应头 SourceMap&quot;">​</a></h3><p>在文件加载时，浏览器会根据 <code>HTTP</code> 响应头 <code>SourceMap</code> 来加载 <code>sourcemap</code> 文件。</p><h3 id="add-source-map" tabindex="-1">Add source map <a class="header-anchor" href="#add-source-map" aria-label="Permalink to &quot;Add source map&quot;">​</a></h3><p>在浏览器中，我们还可以通过手动关联 <code>sourcemap</code> 文件。比如在 <code>Sources</code> 面板中对 <code>js</code> 文件进行手动关联： <img src="'+r+'" alt="addSourcemap"></p><p>关联后，我们就可以在 <code>Sources</code> 面板中调试源码了。</p><h2 id="解决方法" tabindex="-1">解决方法 <a class="header-anchor" href="#解决方法" aria-label="Permalink to &quot;解决方法&quot;">​</a></h2><h2 id="sourcemap-原理" tabindex="-1">Sourcemap 原理 <a class="header-anchor" href="#sourcemap-原理" aria-label="Permalink to &quot;Sourcemap 原理&quot;">​</a></h2><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/SourceMap" target="_blank" rel="noreferrer">SourceMap</a></li><li><a href="https://developer.chrome.com/docs/devtools/developer-resources/" target="_blank" rel="noreferrer">Developer Resources: View and manually load source maps</a></li><li><a href="https://juejin.cn/post/7136049758837145630" target="_blank" rel="noreferrer">彻底搞懂 Webpack 的 sourcemap 配置原理</a></li></ul>',22),s=[p];function t(l,i,u,n,h,m){return a(),o("div",null,s)}const g=e(d,[["render",t]]);export{_ as __pageData,g as default};
