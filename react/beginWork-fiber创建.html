<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>beginWork - fiber的创建 | 秦光辉</title>
    <meta name="description" content="专注于前端开发，关注新技术，坚持学习。">
    <link rel="stylesheet" href="/assets/style.519b55ff.css">
    <link rel="modulepreload" href="/assets/chunks/AlgoliaSearchBox.f359bb5b.js">
    <link rel="modulepreload" href="/assets/app.943409a9.js">
    <link rel="modulepreload" href="/assets/react_beginWork-fiber创建.md.0623a646.lean.js">
    
    <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, minimal-ui">
  <script>var _hmt=_hmt||[];(function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?41a9a03811977ee15c69366a880d1296";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})();</script>
  <meta name="twitter:title" content="beginWork - fiber的创建 | 秦光辉">
  <meta property="og:title" content="beginWork - fiber的创建 | 秦光辉">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme"><header class="nav-bar" data-v-675d8756><div class="sidebar-button" data-v-675d8756><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z" class></path></svg></div><a class="nav-bar-title" href="/" aria-label="秦光辉, back to home" data-v-675d8756 data-v-cc01ef16><img class="logo" src="/logo.png" alt="Logo" data-v-cc01ef16> 秦光辉</a><div class="flex-grow" data-v-675d8756></div><div class="nav" data-v-675d8756><nav class="nav-links" data-v-675d8756 data-v-eab3edfe><!--[--><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item" href="/daily/index" data-v-b8818f8c>日常 <!----></a></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item" href="/articles/index" data-v-b8818f8c>文章 <!----></a></div></div><div class="item" data-v-eab3edfe><div class="nav-dropdown-link" data-v-eab3edfe data-v-56bf3a3f><button class="button" data-v-56bf3a3f><span class="button-text" data-v-56bf3a3f>前端框架</span><span class="right button-arrow" data-v-56bf3a3f></span></button><ul class="dialog" data-v-56bf3a3f><!--[--><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/vue/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Vue v2 源码解析</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/vue3/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Vue v3 源码</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item active" href="/react/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>React v17 源码</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-eab3edfe><div class="nav-dropdown-link" data-v-eab3edfe data-v-56bf3a3f><button class="button" data-v-56bf3a3f><span class="button-text" data-v-56bf3a3f>构建工具</span><span class="right button-arrow" data-v-56bf3a3f></span></button><ul class="dialog" data-v-56bf3a3f><!--[--><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/webpack/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Webpack</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/rollup/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Rollup</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/vite/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Vite</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/babel/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Babel</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-eab3edfe><div class="nav-dropdown-link" data-v-eab3edfe data-v-56bf3a3f><button class="button" data-v-56bf3a3f><span class="button-text" data-v-56bf3a3f>js</span><span class="right button-arrow" data-v-56bf3a3f></span></button><ul class="dialog" data-v-56bf3a3f><!--[--><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/javascript/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>ES6</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/node/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Node</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/typescript/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Typescript</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-eab3edfe><div class="nav-dropdown-link" data-v-eab3edfe data-v-56bf3a3f><button class="button" data-v-56bf3a3f><span class="button-text" data-v-56bf3a3f>基础</span><span class="right button-arrow" data-v-56bf3a3f></span></button><ul class="dialog" data-v-56bf3a3f><!--[--><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/algorithms/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>算法</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/data-structures/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>数据结构</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/design-pattern/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>设计模式</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/leetcode/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>LeetCode</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/network/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>网络</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/linux/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>linux</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-eab3edfe><div class="nav-dropdown-link" data-v-eab3edfe data-v-56bf3a3f><button class="button" data-v-56bf3a3f><span class="button-text" data-v-56bf3a3f>资源</span><span class="right button-arrow" data-v-56bf3a3f></span></button><ul class="dialog" data-v-56bf3a3f><!--[--><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/tools/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>工具</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/resources/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>资料</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item" href="/project/" data-v-b8818f8c>项目 <!----></a></div></div><!--]--><!----><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item isExternal" href="https://github.com/promise96319" target="_blank" rel="noopener noreferrer" data-v-b8818f8c>GitHub <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-b8818f8c><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div></nav></div><!--[--><!--[--><div class="algolia-search-box" id="docsearch"></div><!--]--><!--]--></header><aside class="sidebar" data-v-83e92a68><nav class="nav-links nav" data-v-83e92a68 data-v-eab3edfe><!--[--><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item" href="/daily/index" data-v-b8818f8c>日常 <!----></a></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item" href="/articles/index" data-v-b8818f8c>文章 <!----></a></div></div><div class="item" data-v-eab3edfe><div class="nav-dropdown-link" data-v-eab3edfe data-v-56bf3a3f><button class="button" data-v-56bf3a3f><span class="button-text" data-v-56bf3a3f>前端框架</span><span class="right button-arrow" data-v-56bf3a3f></span></button><ul class="dialog" data-v-56bf3a3f><!--[--><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/vue/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Vue v2 源码解析</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/vue3/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Vue v3 源码</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item active" href="/react/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>React v17 源码</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-eab3edfe><div class="nav-dropdown-link" data-v-eab3edfe data-v-56bf3a3f><button class="button" data-v-56bf3a3f><span class="button-text" data-v-56bf3a3f>构建工具</span><span class="right button-arrow" data-v-56bf3a3f></span></button><ul class="dialog" data-v-56bf3a3f><!--[--><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/webpack/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Webpack</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/rollup/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Rollup</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/vite/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Vite</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/babel/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Babel</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-eab3edfe><div class="nav-dropdown-link" data-v-eab3edfe data-v-56bf3a3f><button class="button" data-v-56bf3a3f><span class="button-text" data-v-56bf3a3f>js</span><span class="right button-arrow" data-v-56bf3a3f></span></button><ul class="dialog" data-v-56bf3a3f><!--[--><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/javascript/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>ES6</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/node/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Node</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/typescript/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>Typescript</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-eab3edfe><div class="nav-dropdown-link" data-v-eab3edfe data-v-56bf3a3f><button class="button" data-v-56bf3a3f><span class="button-text" data-v-56bf3a3f>基础</span><span class="right button-arrow" data-v-56bf3a3f></span></button><ul class="dialog" data-v-56bf3a3f><!--[--><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/algorithms/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>算法</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/data-structures/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>数据结构</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/design-pattern/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>设计模式</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/leetcode/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>LeetCode</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/network/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>网络</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/linux/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>linux</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-eab3edfe><div class="nav-dropdown-link" data-v-eab3edfe data-v-56bf3a3f><button class="button" data-v-56bf3a3f><span class="button-text" data-v-56bf3a3f>资源</span><span class="right button-arrow" data-v-56bf3a3f></span></button><ul class="dialog" data-v-56bf3a3f><!--[--><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/tools/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>工具</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/resources/" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>资料</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><!--]--></ul></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item" href="/project/" data-v-b8818f8c>项目 <!----></a></div></div><!--]--><!----><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item isExternal" href="https://github.com/promise96319" target="_blank" rel="noopener noreferrer" data-v-b8818f8c>GitHub <svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" data-v-b8818f8c><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div></nav><!--[--><!--]--><ul class="sidebar-links" data-v-83e92a68><!--[--><li class="sidebar-link"><a class="sidebar-link-item" href="/react/index">原理</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="/react/react源码调试-next">react源码调试环境构建</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/react/react源码调试">react源码调试</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/react/react源码起始篇">react源码起始篇</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/react/Lanes模型">Lanes模型</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/react/Fiber">Fiber</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/react/浏览器一帧里做了什么">浏览器一帧里做了什么</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/react/任务调度">任务调度</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/react/UpdateQueue">UpdateQueue</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item active" href="/react/beginWork-fiber创建">beginWork-fiber创建</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#开始">开始</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#beginwork">beginWork</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#updatehostroot">updateHostRoot</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#reconcilechildren">reconcileChildren</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#reconcilechildfibers">reconcileChildFibers</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#react-portal-type">REACTPORTALTYPE</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#react-lazy-type">REACTLAZYTYPE</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#react-element-type">REACTELEMENTTYPE</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#type-function">type === function</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#type-string">type === string</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#其他-type">其他 type</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#创建-fiber">创建 fiber</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#diff-算法">diff 算法</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#对比开始部分">对比开始部分</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#对比剩余部分">对比剩余部分</a><!----></li></ul></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="/react/beginWork-fiber更新">beginWork-fiber更新</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/react/completeWork">completeWork</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/react/hooks实现">hooks实现</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/react/commitWork">commitWork</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/react/Suspense实现">Suspense实现</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/react/事件系统">事件系统</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/react/手写简版redux">手写简版redux</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/react/手写简版react-redux">手写简版react-redux</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="/react/阅读资料">阅读资料</a><!----></li></ul></li><!--]--></ul><!--[--><!--]--></aside><div class="sidebar-mask"></div><main class="page" data-v-7eddb2c4><div class="container" data-v-7eddb2c4><!--[--><!--]--><div style="position:relative;" class="content" data-v-7eddb2c4><div><h1 id="beginwork-fiber的创建" tabindex="-1">beginWork - fiber的创建 <a class="header-anchor" href="#beginwork-fiber的创建" aria-hidden="true">#</a></h1><h2 id="开始" tabindex="-1">开始 <a class="header-anchor" href="#开始" aria-hidden="true">#</a></h2><p>更新过程中，调度任务最终执行的小任务是<code>performUnitOfWork</code>：</p><div class="language-javascript"><pre><code><span class="token keyword">function</span> <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">unitOfWork</span><span class="token operator">:</span> Fiber</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> current <span class="token operator">=</span> unitOfWork<span class="token punctuation">.</span>alternate<span class="token punctuation">;</span>

  <span class="token keyword">let</span> next<span class="token punctuation">;</span>
  <span class="token comment">// 为 children 创建 fiber</span>
  <span class="token comment">// 调用 reconcileChildren，建立了当前 unitOfWork 及其 children 的fiber联系</span>
  <span class="token comment">// 并且将 fiber 的 flags 进行了标记，用于替换、移除等操作</span>
  next <span class="token operator">=</span> <span class="token function">beginWork</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> unitOfWork<span class="token punctuation">,</span> subtreeRenderLanes<span class="token punctuation">)</span><span class="token punctuation">;</span>

  unitOfWork<span class="token punctuation">.</span>memoizedProps <span class="token operator">=</span> unitOfWork<span class="token punctuation">.</span>pendingProps<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果没有 next child，那么开始 complete.</span>
    <span class="token comment">// 创建真实节点</span>
    <span class="token function">completeUnitOfWork</span><span class="token punctuation">(</span>unitOfWork<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果存在 next,说明还有 child,继续向下递归 beginWork</span>
    workInProgress <span class="token operator">=</span> next<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>总共分为两步，一是<code>beginWork</code>，二是<code>completeWork</code>。<code>beginWork</code>主要是向下”递“的过程，根据节点创建或复用<code>fiber</code>。<code>completeWork</code>是向上”归“的过程，由下至上根据<code>fiber</code>创建或复用真实节点。</p><h2 id="beginwork" tabindex="-1">beginWork <a class="header-anchor" href="#beginwork" aria-hidden="true">#</a></h2><p><code>beginWork</code>主要分为两部分组成，一部分为<code>reconcilerChildren</code>，主要的作用是为当前的<code>fiber</code>节点的子节点创建<code>fiber</code>，并且建立<code>fiber</code>之间的联系。第二部分是为不同类型的<code>fiber</code>节点更新不同的属性。<code>beginWork</code>的定义是在<code>react-reconciler/src/ReactFiberBeginWork.new.js</code>文件中。</p><h2 id="updatehostroot" tabindex="-1">updateHostRoot <a class="header-anchor" href="#updatehostroot" aria-hidden="true">#</a></h2><p><code>HostRoot</code>的<code>fiber</code>在最开始就已经创建了，也就是之前提到的<code>RootFiber</code>。这里先从<code>updateHostRoot</code>方法开始：</p><div class="language-javascript"><pre><code><span class="token keyword">const</span> nextProps <span class="token operator">=</span> workInProgress<span class="token punctuation">.</span>pendingProps<span class="token punctuation">;</span>
<span class="token keyword">const</span> prevState <span class="token operator">=</span> workInProgress<span class="token punctuation">.</span>memoizedState<span class="token punctuation">;</span>
<span class="token keyword">const</span> prevChildren <span class="token operator">=</span> prevState<span class="token punctuation">.</span>element<span class="token punctuation">;</span>
<span class="token function">cloneUpdateQueue</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">processUpdateQueue</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">,</span> nextProps<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> renderLanes<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> nextState <span class="token operator">=</span> workInProgress<span class="token punctuation">.</span>memoizedState<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>nextChildren <span class="token operator">===</span> prevChildren<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// children 没有变化，提前终止当前child对比，</span>
  <span class="token comment">// 如果有孙子节点变化，那么直接找到对应孙子节点进行处理</span>
  <span class="token keyword">return</span> <span class="token function">bailoutOnAlreadyFinishedWork</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> workInProgress<span class="token punctuation">,</span> renderLanes<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>首先执行<code>processUpdateQueue</code>方法，在<code>UpdateQueue</code>章节中已经提到，该方法主要是执行<code>updateQueue</code>返回一个新的<code>state</code>。如果前后的<code>state</code>一致，那么可以跳过后续的<code>reconcile</code>阶段。如果不一致，就需要执行<code>reconcileChildren</code>方法为子节点分别创建<code>fiber</code>了。</p><div class="language-javascript"><pre><code><span class="token function">reconcileChildren</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> workInProgress<span class="token punctuation">,</span> nextChildren<span class="token punctuation">,</span> renderLanes<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="reconcilechildren" tabindex="-1">reconcileChildren <a class="header-anchor" href="#reconcilechildren" aria-hidden="true">#</a></h2><p><code>reconcileChildren</code>分为两种情况：</p><div class="language-javascript"><pre><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">reconcileChildren</span><span class="token punctuation">(</span>
  <span class="token literal-property property">current</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token comment">// 老的 fiber</span>
  <span class="token literal-property property">workInProgress</span><span class="token operator">:</span> Fiber<span class="token punctuation">,</span> <span class="token comment">// 当前工作的 fiber，新fiber</span>
  <span class="token literal-property property">nextChildren</span><span class="token operator">:</span> any<span class="token punctuation">,</span> <span class="token comment">// 新 fiber pendingProps 上的 children</span>
  <span class="token literal-property property">renderLanes</span><span class="token operator">:</span> Lanes<span class="token punctuation">,</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    workInProgress<span class="token punctuation">.</span>child <span class="token operator">=</span> <span class="token function">mountChildFibers</span><span class="token punctuation">(</span>
      workInProgress<span class="token punctuation">,</span>
      <span class="token keyword">null</span><span class="token punctuation">,</span>
      nextChildren<span class="token punctuation">,</span>
      renderLanes<span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    workInProgress<span class="token punctuation">.</span>child <span class="token operator">=</span> <span class="token function">reconcileChildFibers</span><span class="token punctuation">(</span>
      workInProgress<span class="token punctuation">,</span>
      current<span class="token punctuation">.</span>child<span class="token punctuation">,</span>
      nextChildren<span class="token punctuation">,</span>
      renderLanes<span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>一种是<code>current</code>存在，一种是<code>current</code>不存在，他们唯一的区别就是第二个参数不一致。找到<code>ReactChildFiber.new.js</code>文件：</p><div class="language-javascript"><pre><code><span class="token keyword">export</span> <span class="token keyword">const</span> reconcileChildFibers <span class="token operator">=</span> <span class="token function">ChildReconciler</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> mountChildFibers <span class="token operator">=</span> <span class="token function">ChildReconciler</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>它们的区别就是第一个参数不同，实际上与<code>current</code>存不存在是具有一定关系的。这个参数尤为关键，它会影响到后续的<code>fiber.flags</code>的值。</p><h2 id="reconcilechildfibers" tabindex="-1">reconcileChildFibers <a class="header-anchor" href="#reconcilechildfibers" aria-hidden="true">#</a></h2><p>我们先来看一下<code>reconcileChildFibers</code>方法，当<code>newChild</code>为<code>string/number</code>时比较简单，就是一个<code>text</code>节点。我们主要讨论为<code>object</code>的情况，其中<code>newChild.$$typeof</code>主要分为三种情况：</p><h3 id="react-portal-type" tabindex="-1">REACT_PORTAL_TYPE <a class="header-anchor" href="#react-portal-type" aria-hidden="true">#</a></h3><p>此节点是由<code>React.createPortal</code>方法创建:</p><div class="language-javascript"><pre><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createPortal</span><span class="token punctuation">(</span>
  <span class="token parameter"><span class="token literal-property property">children</span><span class="token operator">:</span> ReactNodeList<span class="token punctuation">,</span>
  <span class="token literal-property property">containerInfo</span><span class="token operator">:</span> any<span class="token punctuation">,</span>
  <span class="token literal-property property">implementation</span><span class="token operator">:</span> any<span class="token punctuation">,</span>
  <span class="token literal-property property">key</span><span class="token operator">:</span> <span class="token operator">?</span>string <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span></span>
<span class="token punctuation">)</span><span class="token operator">:</span> ReactPortal <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    $$<span class="token keyword">typeof</span><span class="token operator">:</span> <span class="token constant">REACT_PORTAL_TYPE</span><span class="token punctuation">,</span>
    <span class="token literal-property property">key</span><span class="token operator">:</span> key <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> <span class="token string">&#39;&#39;</span> <span class="token operator">+</span> key<span class="token punctuation">,</span>
    children<span class="token punctuation">,</span>
    containerInfo<span class="token punctuation">,</span>
    implementation<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>此时<code>jsx</code>解析出来的<code>type</code>就是返回的<code>type</code>。而这个<code>type</code>里的<code>$$typeof</code>是<code>REACT_PORTAL_TYPE</code>。</p><h3 id="react-lazy-type" tabindex="-1">REACT_LAZY_TYPE <a class="header-anchor" href="#react-lazy-type" aria-hidden="true">#</a></h3><p>此时调用的<code>React.lazy</code>方法创建的节点:</p><div class="language-javascript"><pre><code><span class="token keyword">export</span> <span class="token keyword">function</span> lazy<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>
  <span class="token function-variable function">ctor</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Thenable<span class="token operator">&lt;</span><span class="token punctuation">{</span><span class="token keyword">default</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token operator">:</span> LazyComponent<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> Payload<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token literal-property property">payload</span><span class="token operator">:</span> Payload<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">_status</span><span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token literal-property property">_result</span><span class="token operator">:</span> ctor<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> <span class="token literal-property property">lazyType</span><span class="token operator">:</span> LazyComponent<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> Payload<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    $$<span class="token keyword">typeof</span><span class="token operator">:</span> <span class="token constant">REACT_LAZY_TYPE</span><span class="token punctuation">,</span>
    <span class="token literal-property property">_payload</span><span class="token operator">:</span> payload<span class="token punctuation">,</span>
    <span class="token literal-property property">_init</span><span class="token operator">:</span> lazyInitializer<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> lazyType<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="react-element-type" tabindex="-1">REACT_ELEMENT_TYPE <a class="header-anchor" href="#react-element-type" aria-hidden="true">#</a></h3><p>当<code>$$typeof</code>为<code>REACT_ELEMENT_TYPE</code>的时候，会调用<code>reconcileSingleElement</code>方法。</p><div class="language-javascript"><pre><code><span class="token keyword">return</span> <span class="token function">placeSingleChild</span><span class="token punctuation">(</span>
  <span class="token function">reconcileSingleElement</span><span class="token punctuation">(</span>
    returnFiber<span class="token punctuation">,</span>
    currentFirstChild<span class="token punctuation">,</span>
    newChild<span class="token punctuation">,</span>
    lanes<span class="token punctuation">,</span>
	<span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
       
</code></pre></div><p>在<code>reconcileSingleElement</code>方法里会校验<code>key</code>和<code>type</code>是否一致，如果一致则使用<code>useFiber</code>方法进行复用<code>fiber</code>。<code>useFiber</code>方法会调用<code>createWorkInProgress</code>方法：</p><div class="language-javascript"><pre><code><span class="token keyword">let</span> workInProgress <span class="token operator">=</span> current<span class="token punctuation">.</span>alternate<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>workInProgress <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token comment">// 真实节点也被复用了</span>
  workInProgress<span class="token punctuation">.</span>stateNode <span class="token operator">=</span> current<span class="token punctuation">.</span>stateNode<span class="token punctuation">;</span>

  <span class="token comment">// 每次创建的时候会建立相应的关系</span>
  workInProgress<span class="token punctuation">.</span>alternate <span class="token operator">=</span> current<span class="token punctuation">;</span>
  current<span class="token punctuation">.</span>alternate <span class="token operator">=</span> workInProgress<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果<code>current.alternate</code>不存在，那么会以<code>current</code>为基准，创建新的<code>fiber</code>，<strong>并且新的fiber和current之间通过alternate属性建立联系。除此之外，新的fiber还会复用current的stateNode，实际上是复用了fiber对应的真实节点。</strong></p><p>如果<code>key</code>或者<code>type</code>不一致时，会调用<code>createFiberFromElement</code>方法根据<code>jsx</code>解析出来的<code>ReactElement</code>创建新的<code>fiber</code>，该方法又会调用<code>createFiberFromTypeAndProps</code>方法来创建<code>fiber</code>，在<code>ReactFiber.new.js</code>文件中找到<code>createFiberFromTypeAndProps</code>方法：</p><div class="language-javascript"><pre><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> type <span class="token operator">===</span> <span class="token string">&#39;function&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldConstruct</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    fiberTag <span class="token operator">=</span> ClassComponent<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="type-function" tabindex="-1">type === function <a class="header-anchor" href="#type-function" aria-hidden="true">#</a></h3><p>如果<code>type</code>为<code>function</code>，可能是<code>class</code>组件也可能是函数组件。</p><div class="language-javascript"><pre><code><span class="token keyword">function</span> <span class="token function">shouldConstruct</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">Component</span><span class="token operator">:</span> Function</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> prototype <span class="token operator">=</span> <span class="token class-name">Component</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>prototype <span class="token operator">&amp;&amp;</span> prototype<span class="token punctuation">.</span>isReactComponent<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果<code>shouldConstruct(type)</code>为<code>true</code>，说明<code>isReactComponent</code>存在。但是<code>isReactComponent</code>在哪里定义的呢？我们在写类组件的时候通常会写<code>extends Component</code>，在<code>ReactBaseClass.new.js</code>文件中找到<code>Component</code>的定义：</p><div class="language-javascript"><pre><code><span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> context<span class="token punctuation">,</span> updater</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>props <span class="token operator">=</span> props<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>context <span class="token operator">=</span> context<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>refs <span class="token operator">=</span> emptyObject<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>updater <span class="token operator">=</span> updater <span class="token operator">||</span> ReactNoopUpdateQueue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">Component</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>isReactComponent <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>可以看出<code>class</code>组件的<code>isReactComponent</code>是存在的，也就是当<code>shouldConstruct(type)</code>存在时，表示他为<code>class</code>组件。</p><h3 id="type-string" tabindex="-1">type === string <a class="header-anchor" href="#type-string" aria-hidden="true">#</a></h3><p>当<code>type</code>为<code>string</code>的时候，说明是普通标签，统一标记为<code>HostComponent</code></p><div class="language-javascript"><pre><code><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> type <span class="token operator">===</span> <span class="token string">&#39;string&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	fiberTag <span class="token operator">=</span> HostComponent<span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
</code></pre></div><h3 id="其他-type" tabindex="-1">其他 type <a class="header-anchor" href="#其他-type" aria-hidden="true">#</a></h3><p>其他的都是<code>React</code>定义的一些<code>type</code>，比如<code>REACT_FRAGMENT_TYPE</code>、<code>REACT_SUSPENSE_TYPE</code>等。需要注意的是<code>type</code>为<code>object</code>的时候，<code>REACT_PROVIDER_TYPE</code>、<code>REACT_CONTEXT_TYPE</code>等<code>fiber</code>是在这个位置创建的。</p><div class="language-javascript"><pre><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> type <span class="token operator">===</span> <span class="token string">&#39;object&#39;</span> <span class="token operator">&amp;&amp;</span> type <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">switch</span> <span class="token punctuation">(</span>type<span class="token punctuation">.</span>$$<span class="token keyword">typeof</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">case</span> <span class="token constant">REACT_PROVIDER_TYPE</span><span class="token operator">:</span>
			fiberTag <span class="token operator">=</span> ContextProvider<span class="token punctuation">;</span>
			<span class="token keyword">break</span> getTag<span class="token punctuation">;</span>
		<span class="token keyword">case</span> <span class="token constant">REACT_CONTEXT_TYPE</span><span class="token operator">:</span>
			fiberTag <span class="token operator">=</span> ContextConsumer<span class="token punctuation">;</span>
      <span class="token keyword">break</span> getTag<span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token constant">REACT_FORWARD_REF_TYPE</span><span class="token operator">:</span>
      fiberTag <span class="token operator">=</span> ForwardRef<span class="token punctuation">;</span>
			<span class="token keyword">break</span> getTag<span class="token punctuation">;</span>
		<span class="token keyword">case</span> <span class="token constant">REACT_MEMO_TYPE</span><span class="token operator">:</span>
			fiberTag <span class="token operator">=</span> MemoComponent<span class="token punctuation">;</span>
			<span class="token keyword">break</span> getTag<span class="token punctuation">;</span>
		<span class="token keyword">case</span> <span class="token constant">REACT_LAZY_TYPE</span><span class="token operator">:</span>
			fiberTag <span class="token operator">=</span> LazyComponent<span class="token punctuation">;</span>
			resolvedType <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
			<span class="token keyword">break</span> getTag<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="创建-fiber" tabindex="-1">创建 fiber <a class="header-anchor" href="#创建-fiber" aria-hidden="true">#</a></h3><p>标记完<code>fiberTag</code>，最后开始创建<code>fiber</code>：</p><div class="language-javascript"><pre><code><span class="token keyword">const</span> fiber <span class="token operator">=</span> <span class="token function">createFiber</span><span class="token punctuation">(</span>fiberTag<span class="token punctuation">,</span> pendingProps<span class="token punctuation">,</span> key<span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
fiber<span class="token punctuation">.</span>elementType <span class="token operator">=</span> type<span class="token punctuation">;</span>
fiber<span class="token punctuation">.</span>type <span class="token operator">=</span> resolvedType<span class="token punctuation">;</span>
</code></pre></div><p>这里的<code>fiberTag</code>是<code>React</code>中对应的一套标签<code>Tag</code>。<code>elementType</code>是<code>jsx</code>解析出来的<code>type</code>，而<code>fiber.type</code>则是处理过后的<code>type</code>，因此<code>elementType</code>和<code>type</code>会存在不一致的情况。</p><h2 id="diff-算法" tabindex="-1">diff 算法 <a class="header-anchor" href="#diff-算法" aria-hidden="true">#</a></h2><p>回到<code>reconcileChildFibers</code>方法，除了对象形式的<code>newChild</code>外，还可能存在数组形式的<code>newChild</code>，会进入<code>isArray</code>分支：</p><div class="language-javascript"><pre><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isArray</span><span class="token punctuation">(</span>newChild<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// diff 算法</span>
	<span class="token keyword">return</span> <span class="token function">reconcileChildrenArray</span><span class="token punctuation">(</span>
		returnFiber<span class="token punctuation">,</span>
		currentFirstChild<span class="token punctuation">,</span>
		newChild<span class="token punctuation">,</span>
		lanes<span class="token punctuation">,</span>
	<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个分支的主要作用就是对比<code>newChild</code>(也就是<code>jsx</code>接下出来的<code>ReactElement</code>)和已有的老<code>fiber</code>结构，进行复用<code>fiber</code>和真实节点，并且对<code>fiber</code>标记删除、替换等操作。这个对比的过程就是<code>diff</code>算法。</p><h3 id="对比开始部分" tabindex="-1">对比开始部分 <a class="header-anchor" href="#对比开始部分" aria-hidden="true">#</a></h3><p>以一个简单的例子开始：假如老节点<code>A，B，C，D，E</code>对应5个老<code>fiber</code>，现在新节点解析出来的是<code>A，B，D，E，F</code>5个<code>ReactElement</code>（在未处理成<code>fiber</code>之前）。最开始时我们需要依次从头到尾进行对比(主要是对比<code>key</code>和<code>type</code>两个属性)，发现<code>A，B</code>是可以复用的，但是<code>C</code>和<code>D</code>不一致，不能复用，此时退出当前对比部分。<code>React</code>这部分对比的代码如下：</p><div class="language-javascript"><pre><code><span class="token comment">// oldFiber 是老 fiber 的第一个 child，可以通过 sibling 进行遍历。</span>
<span class="token keyword">let</span> oldFiber <span class="token operator">=</span> currentFirstChild<span class="token punctuation">;</span>
<span class="token comment">// lastPlacedIndex 表示最后一个老fiber被复用的位置</span>
<span class="token keyword">let</span> lastPlacedIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token comment">// 表示新 ReactElement 的位置</span>
<span class="token keyword">let</span> newIdx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token comment">// 表示下一个老fiber</span>
<span class="token keyword">let</span> nextOldFiber <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

<span class="token comment">// Diff 算法，标记子节点中需要的操作，记录在 flags 中</span>
<span class="token comment">// 这个位置相当于只对比了前面的一部分，</span>
<span class="token comment">// 如果出现 key 和 type 不一致的情况，那么会跳出对比。</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span>oldFiber <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> newIdx <span class="token operator">&lt;</span> newChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span>newIdx<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>oldFiber<span class="token punctuation">.</span>index <span class="token operator">&gt;</span> newIdx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 这里相当于 一直找到 old fiber index 与 newIdx 相等的节点</span>
    <span class="token comment">// 否则的话，oldFiber 不向后遍历。</span>
    nextOldFiber <span class="token operator">=</span> oldFiber<span class="token punctuation">;</span>
    oldFiber <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 遍历下一个 fiber </span>
    nextOldFiber <span class="token operator">=</span> oldFiber<span class="token punctuation">.</span>sibling<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token comment">// 这里的 newChildren 是 jsx 解析出来的 children，为 ReactElement节点</span>
  <span class="token comment">// 根据节点创建或者更新 fiber</span>
  <span class="token keyword">const</span> newFiber <span class="token operator">=</span> <span class="token function">updateSlot</span><span class="token punctuation">(</span>
    returnFiber<span class="token punctuation">,</span>
    oldFiber<span class="token punctuation">,</span> <span class="token comment">// 老 fiber</span>
    newChildren<span class="token punctuation">[</span>newIdx<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 新 element</span>
    lanes<span class="token punctuation">,</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// key 或 type 不相同时，不可复用。</span>
  <span class="token comment">// 此时 newFiber 为 null，对比就会终止。</span>
  <span class="token comment">// 这就意味着找到了第一个无法复用的节点</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>newFiber <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldFiber <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      oldFiber <span class="token operator">=</span> nextOldFiber<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token comment">// 首次创建的时候无需记录，但是更新的时候需要记录</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>shouldTrackSideEffects<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldFiber <span class="token operator">&amp;&amp;</span> newFiber<span class="token punctuation">.</span>alternate <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 将老的fiber标记为删除</span>
      <span class="token function">deleteChild</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> oldFiber<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  
  <span class="token comment">// 取 current.index 和 lastPlacedIndex 最大值</span>
  lastPlacedIndex <span class="token operator">=</span> <span class="token function">placeChild</span><span class="token punctuation">(</span>newFiber<span class="token punctuation">,</span> lastPlacedIndex<span class="token punctuation">,</span> newIdx<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 建立 新fiber 之间的联系</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>previousNewFiber <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    resultingFirstChild <span class="token operator">=</span> newFiber<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    previousNewFiber<span class="token punctuation">.</span>sibling <span class="token operator">=</span> newFiber<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  previousNewFiber <span class="token operator">=</span> newFiber<span class="token punctuation">;</span>
  oldFiber <span class="token operator">=</span> nextOldFiber<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>遍历跳出之后，会判断老<code>fiber</code>或者是新<code>ReactElement</code>遍历完成没。如果新<code>ReactElement</code>遍历完成，那么所有剩余的老<code>fiber</code>都应该标记为删除：</p><div class="language-javascript"><pre><code><span class="token keyword">if</span> <span class="token punctuation">(</span>newIdx <span class="token operator">===</span> newChildren<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 标记删除，记录到 父 fiber 的 deletions 属性中</span>
  <span class="token function">deleteRemainingChildren</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> oldFiber<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> resultingFirstChild<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果老<code>fiber</code>遍历完成，那么所有剩余新的<code>ReactElement</code>都是新插入的节点，创建<code>newFiber</code></p><div class="language-javascript"><pre><code><span class="token keyword">if</span> <span class="token punctuation">(</span>oldFiber <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span>newIdx <span class="token operator">&lt;</span> newChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span>newIdx<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> newFiber <span class="token operator">=</span> <span class="token function">createChild</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> newChildren<span class="token punctuation">[</span>newIdx<span class="token punctuation">]</span><span class="token punctuation">,</span> lanes<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newFiber <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">continue</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    lastPlacedIndex <span class="token operator">=</span> <span class="token function">placeChild</span><span class="token punctuation">(</span>newFiber<span class="token punctuation">,</span> lastPlacedIndex<span class="token punctuation">,</span> newIdx<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>previousNewFiber <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      resultingFirstChild <span class="token operator">=</span> newFiber<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      previousNewFiber<span class="token punctuation">.</span>sibling <span class="token operator">=</span> newFiber<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    previousNewFiber <span class="token operator">=</span> newFiber<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> resultingFirstChild<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>显然例子中还剩余<code>C，D，E</code>和<code>D，E，F</code>没有进行对比。</p><h3 id="对比剩余部分" tabindex="-1">对比剩余部分 <a class="header-anchor" href="#对比剩余部分" aria-hidden="true">#</a></h3><p>如果老<code>fiber</code>和新<code>ReactElement</code>都有剩余，那么寻找可复用的<code>fiber</code>。对比代码如下：</p><div class="language-javascript"><pre><code><span class="token comment">// 后续的是因为 key 和 type 不一致导致没有遍历完的数组。</span>
<span class="token comment">// 此时开始复用的算法。</span>
<span class="token comment">// 首先将老节点转换为 map 形式：{ key|index : fiber }</span>
<span class="token keyword">const</span> existingChildren <span class="token operator">=</span> <span class="token function">mapRemainingChildren</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> oldFiber<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span>newIdx <span class="token operator">&lt;</span> newChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span>newIdx<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 找到相应的可复用的 fiber</span>
  <span class="token keyword">const</span> newFiber <span class="token operator">=</span> <span class="token function">updateFromMap</span><span class="token punctuation">(</span>
    existingChildren<span class="token punctuation">,</span>
    returnFiber<span class="token punctuation">,</span>
    newIdx<span class="token punctuation">,</span>
    newChildren<span class="token punctuation">[</span>newIdx<span class="token punctuation">]</span><span class="token punctuation">,</span>
    lanes<span class="token punctuation">,</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 如果找到了对应的 fiber</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>newFiber <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>shouldTrackSideEffects<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>newFiber<span class="token punctuation">.</span>alternate <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果已经复用了，在老节点中删除对应的 fiber</span>
        existingChildren<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>
          newFiber<span class="token punctuation">.</span>key <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">?</span> newIdx <span class="token operator">:</span> newFiber<span class="token punctuation">.</span>key<span class="token punctuation">,</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 能复用时，更新最后一个复用的 老fiber 的 index</span>
    lastPlacedIndex <span class="token operator">=</span> <span class="token function">placeChild</span><span class="token punctuation">(</span>newFiber<span class="token punctuation">,</span> lastPlacedIndex<span class="token punctuation">,</span> newIdx<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>previousNewFiber <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      resultingFirstChild <span class="token operator">=</span> newFiber<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      previousNewFiber<span class="token punctuation">.</span>sibling <span class="token operator">=</span> newFiber<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    previousNewFiber <span class="token operator">=</span> newFiber<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>shouldTrackSideEffects<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 将所有没有被复用的老fiber标记为删除</span>
  existingChildren<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">child</span> <span class="token operator">=&gt;</span> <span class="token function">deleteChild</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> child<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里最重要的一点是<code>placeChild</code>方法：</p><div class="language-javascript"><pre><code><span class="token comment">// 用于 diff 算法，标记最后匹配的 old fiber 的位置</span>
<span class="token keyword">function</span> <span class="token function">placeChild</span><span class="token punctuation">(</span>
  <span class="token parameter"><span class="token literal-property property">newFiber</span><span class="token operator">:</span> Fiber<span class="token punctuation">,</span>
  <span class="token literal-property property">lastPlacedIndex</span><span class="token operator">:</span> number<span class="token punctuation">,</span>
  <span class="token literal-property property">newIndex</span><span class="token operator">:</span> number<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span><span class="token operator">:</span> number <span class="token punctuation">{</span>
  newFiber<span class="token punctuation">.</span>index <span class="token operator">=</span> newIndex<span class="token punctuation">;</span>
  <span class="token comment">// 当父亲的 current 不存在时，此时为 mount，shouldTrackSideEffects 为 false，不用做处理。</span>
  <span class="token comment">// 当父亲的 current 存在时，shouldTrackSideEffects 为 true。</span>
  <span class="token comment">// 例如，当遇到第一个需要重新创建的节点时，它对应的 parent 的 current 存在，标记为更新。</span>
  <span class="token comment">// 当遍历到子节点时，由于子节点对应的 parent 的 current 不存在，此时不标记更新。</span>
  <span class="token comment">// 这样做的好处是，只有父亲被标记为更新，而其后代均不作标记。</span>
  <span class="token comment">// 在 completeWork 的时候子节点直接全添加到父亲上。</span>
  <span class="token comment">// 在 commit 的时候只需要将父亲添加到 根节点上即可。</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>shouldTrackSideEffects<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> lastPlacedIndex<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 如果复用了 老fiber</span>
  <span class="token keyword">const</span> current <span class="token operator">=</span> newFiber<span class="token punctuation">.</span>alternate<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> oldIndex <span class="token operator">=</span> current<span class="token punctuation">.</span>index<span class="token punctuation">;</span>
    <span class="token comment">// 如果老的 index &lt; lastPlacedIndex，说明这些老的节点无法复用。</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldIndex <span class="token operator">&lt;</span> lastPlacedIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 不可复用，需要替换</span>
      newFiber<span class="token punctuation">.</span>flags <span class="token operator">|=</span> Placement<span class="token punctuation">;</span>
      <span class="token keyword">return</span> lastPlacedIndex<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// This item can stay in place.</span>
      <span class="token comment">// 否则说明这个老节点可以复用，返回老节点 index</span>
      <span class="token keyword">return</span> oldIndex<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果 老 fiber不存在，那么需要替换</span>
    <span class="token comment">// 注意这里被标记了，commit的时候会进行处理</span>
    newFiber<span class="token punctuation">.</span>flags <span class="token operator">|=</span> Placement<span class="token punctuation">;</span>
    <span class="token keyword">return</span> lastPlacedIndex<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>该方法用于标记<code>fiber</code>是否为<code>Placement</code>。并且会更新<code>lastPlacedIndex</code>，该变量记录了最后一个被复用的老<code>fiber</code>的位置，因此这个老<code>fiber</code>前面的<code>fiber</code>就不应该被后续的<code>ReactElement</code>复用，从而达到移动的目的。比如<code>C，D，E</code>和<code>D，E，F</code>中<code>D</code>复用时，<code>lastPlacedIndex</code>为3，<code>E</code>复用时，<code>lastPlacedIndex</code>为4，<code>F</code>无法复用，此时创建新<code>fiber</code>，而老<code>fiber</code>中<code>C</code>没有被复用，那么会标记为删除。假设新的节点为 <code>D，E，C</code>，那么<code>C</code>会被复用吗？答案是不能，因为<code>lastPlacedIndex</code>为4，而老节点中<code>C</code>的位置为2，小于4，只能标记为删除，而不能复用。</p></div></div><footer class="page-footer" data-v-7eddb2c4 data-v-07c132fc><div class="edit" data-v-07c132fc><div class="edit-link" data-v-07c132fc data-v-1ed99556><!----></div></div><div class="updated" data-v-07c132fc><p class="last-updated" data-v-07c132fc data-v-abce3432><span class="prefix" data-v-abce3432>最近更新:</span><span class="datetime" data-v-abce3432></span></p></div></footer><div class="next-and-prev-link" data-v-7eddb2c4 data-v-38ede35f><div class="container" data-v-38ede35f><div class="prev" data-v-38ede35f><a class="link" href="/react/UpdateQueue" data-v-38ede35f><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon icon-prev" data-v-38ede35f><path d="M19,11H7.4l5.3-5.3c0.4-0.4,0.4-1,0-1.4s-1-0.4-1.4,0l-7,7c-0.1,0.1-0.2,0.2-0.2,0.3c-0.1,0.2-0.1,0.5,0,0.8c0.1,0.1,0.1,0.2,0.2,0.3l7,7c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3c0.4-0.4,0.4-1,0-1.4L7.4,13H19c0.6,0,1-0.4,1-1S19.6,11,19,11z"></path></svg><span class="text" data-v-38ede35f>UpdateQueue</span></a></div><div class="next" data-v-38ede35f><a class="link" href="/react/beginWork-fiber更新" data-v-38ede35f><span class="text" data-v-38ede35f>beginWork-fiber更新</span><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon icon-next" data-v-38ede35f><path d="M19.9,12.4c0.1-0.2,0.1-0.5,0-0.8c-0.1-0.1-0.1-0.2-0.2-0.3l-7-7c-0.4-0.4-1-0.4-1.4,0s-0.4,1,0,1.4l5.3,5.3H5c-0.6,0-1,0.4-1,1s0.4,1,1,1h11.6l-5.3,5.3c-0.4,0.4-0.4,1,0,1.4c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3l7-7C19.8,12.6,19.9,12.5,19.9,12.4z"></path></svg></a></div></div></div><!--[--><!--]--></div></main></div><!----><!--]--></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"about_readme.md\":\"11341125\",\"about_index.md\":\"8d78829d\",\"about_plan.md\":\"a576da24\",\"algorithms_index.md\":\"0e31c79e\",\"algorithms_二叉树.md\":\"2b4187ff\",\"algorithms_动态规划.md\":\"01b26f7c\",\"algorithms_回溯法.md\":\"3c5208ef\",\"algorithms_字符串.md\":\"5380bee9\",\"algorithms_排序汇总.md\":\"f35ebada\",\"algorithms_数组.md\":\"d1f137c6\",\"algorithms_树结构遍历.md\":\"3298eabd\",\"articles_index.md\":\"1b974fba\",\"articles_react-concurrency.md\":\"ce239c74\",\"articles_todo.md\":\"3b550e52\",\"babel_index.md\":\"cd5e0aa2\",\"computer_index.md\":\"9fed4698\",\"daily_2022_05.md\":\"48586742\",\"daily_2022_06.md\":\"2abf3e80\",\"daily_2022_07.md\":\"93aa2d1e\",\"daily_2022_08.md\":\"19e80f7f\",\"daily_2022_09.md\":\"28b1eec6\",\"daily_index.md\":\"6d6a9136\",\"data-structures_index.md\":\"96819b80\",\"data-structures_二叉查找树.md\":\"a0136630\",\"data-structures_哈希表.md\":\"e4035977\",\"data-structures_堆.md\":\"25c66957\",\"data-structures_字典树.md\":\"6562d369\",\"data-structures_布隆过滤器.md\":\"8a1995dc\",\"data-structures_平衡二叉树.md\":\"097cdc11\",\"data-structures_并查集.md\":\"2931289a\",\"data-structures_树状数组.md\":\"e078ba93\",\"data-structures_红黑树.md\":\"2e022d36\",\"data-structures_线段树.md\":\"c204a054\",\"design-pattern_index.md\":\"7acb2038\",\"design-pattern_创建型模式.md\":\"94099c3f\",\"design-pattern_结构型模式.md\":\"19026e61\",\"design-pattern_行为型模式.md\":\"b3d11929\",\"design-pattern_阅读资料.md\":\"647ac039\",\"index.md\":\"58c33957\",\"javascript_typescript.md\":\"b379322b\",\"javascript_co库.md\":\"31466838\",\"javascript_es6.md\":\"707334f8\",\"javascript_index.md\":\"1fb52574\",\"javascript_js方法实现.md\":\"663f8110\",\"javascript_js继承.md\":\"db268ca2\",\"javascript_事件循环机制.md\":\"c6e95f5a\",\"javascript_函数式编程.md\":\"1cdc4194\",\"javascript_手写promise.md\":\"09605dc7\",\"leetcode_1-20.md\":\"ed1d8a80\",\"leetcode_21-40.md\":\"203c2ca4\",\"leetcode_index.md\":\"c9714c28\",\"leetcode_leetcode.md\":\"2e0f12ff\",\"linux_bash.md\":\"b47248ce\",\"linux_index.md\":\"770199bb\",\"linux_ssh.md\":\"a494deda\",\"linux_vim.md\":\"d348205a\",\"network_index.md\":\"b6983808\",\"network_应用层.md\":\"97e03e8c\",\"network_缓存.md\":\"1342e8ba\",\"network_运输层.md\":\"c0410fa8\",\"node_compose.md\":\"46769e40\",\"node_index.md\":\"742d489b\",\"node_手写简版express.md\":\"30a54120\",\"node_资料.md\":\"880d6482\",\"node_进程与线程.md\":\"173ffd90\",\"project_css-background-img.md\":\"0343060d\",\"project_css-hack.md\":\"04734a82\",\"project_css-media.md\":\"8624694b\",\"project_drawer.md\":\"6273d7c1\",\"project_index.md\":\"6bfd2548\",\"project_space.md\":\"16494b72\",\"react_fiber.md\":\"a45ee55d\",\"react_lanes模型.md\":\"e1ff0f18\",\"react_suspense实现.md\":\"daf263c6\",\"react_updatequeue.md\":\"4ca3cf44\",\"react_beginwork-fiber创建.md\":\"0623a646\",\"react_beginwork-fiber更新.md\":\"abbe5631\",\"react_commitwork.md\":\"baab8382\",\"react_completework.md\":\"a2a0357d\",\"react_hooks实现.md\":\"c24aa84c\",\"react_index.md\":\"c973bc02\",\"react_react源码调试-next.md\":\"bda2eeb1\",\"react_react源码调试.md\":\"3467b78a\",\"react_react源码起始篇.md\":\"b5b7f1d3\",\"react_react热更新实现原理.md\":\"d3d5b6b4\",\"react_tmp.md\":\"da56a2e4\",\"react_事件系统.md\":\"4f7a3c25\",\"react_任务调度.md\":\"51c1431e\",\"react_学习计划.md\":\"d2cd4bbd\",\"react_手写简版react-redux.md\":\"6058f8bb\",\"react_手写简版redux.md\":\"6bd7e63e\",\"react_浏览器一帧里做了什么.md\":\"0ef5098f\",\"react_渲染.md\":\"7f8dc696\",\"react_阅读资料.md\":\"1bdcb850\",\"resources_index.md\":\"4fb06d25\",\"resources_js.md\":\"c2c4e759\",\"resources_前端博客.md\":\"5be7470b\",\"resources_小程序.md\":\"9a52cfed\",\"resources_算法.md\":\"0998f33f\",\"resources_网络协议.md\":\"3a92b214\",\"rollup_plugin.md\":\"219c5713\",\"rollup_scopehoist.md\":\"413172e2\",\"rollup_splitcode.md\":\"5ad8f5e5\",\"rollup_treeshaking.md\":\"571b45fb\",\"rollup_index.md\":\"595ccc14\",\"rollup_todo.md\":\"6535c62c\",\"rollup_源码调试.md\":\"0427b11e\",\"static_index.md\":\"2db634bd\",\"tools_github-workflow.md\":\"a6906e5b\",\"tools_img-library.md\":\"b1964cec\",\"tools_index.md\":\"de5545e5\",\"tools_iterm2-ohmyzsh.md\":\"ecba21ed\",\"tools_jinkins.md\":\"4b44ed2d\",\"tools_software.md\":\"1e1f2bd1\",\"trend_bundleless.md\":\"e5c0be26\",\"trend_index.md\":\"1305b267\",\"trend_jiti.md\":\"ea6e567e\",\"typescript_index.md\":\"1b95402f\",\"typescript_utility-types.md\":\"3192b808\",\"vite_index.md\":\"ce1d53df\",\"vite_源码调试.md\":\"4de78376\",\"vue_index.md\":\"d2985218\",\"vue_一些原理汇总.md\":\"0a37beaf\",\"vue_响应式原理上篇.md\":\"a693c210\",\"vue_响应式原理下篇.md\":\"a3ec4372\",\"vue_响应式原理中篇.md\":\"3431de55\",\"vue_手写简版vuerouter.md\":\"e4e252f0\",\"vue_手写简版vuex.md\":\"e36e4b9a\",\"vue_插槽实现原理.md\":\"58ff1772\",\"vue_最长递增子序列.md\":\"8d748640\",\"vue_组件实现原理.md\":\"3c823154\",\"vue_组成与设计.md\":\"04daef8f\",\"vue_编译原理上篇.md\":\"be961455\",\"vue_编译原理下篇.md\":\"d2d6371b\",\"vue_编译原理中篇.md\":\"076d384d\",\"vue_选项合并.md\":\"b4b55836\",\"vue_阅读资料.md\":\"fcc8ad30\",\"vue3_index.md\":\"30939cf2\",\"vue3_源码调试.md\":\"fb4c0c36\",\"webpack_splitchunksplugin.md\":\"bea22b54\",\"webpack_tapable.md\":\"7e2e0b09\",\"webpack_treeshaking原理.md\":\"e6483a90\",\"webpack_addmodule.md\":\"178b4f4c\",\"webpack_buildmodule.md\":\"6ce98298\",\"webpack_emit阶段.md\":\"2e63d731\",\"webpack_factorizemodule.md\":\"9302ce46\",\"webpack_import.md\":\"96727e90\",\"webpack_index.md\":\"994aa72f\",\"webpack_make阶段.md\":\"6c51c62c\",\"webpack_seal阶段.md\":\"ffd274b8\",\"webpack_vue-loader实现.md\":\"fce864eb\",\"webpack_watch实现.md\":\"65181ee2\",\"webpack_webpack优化.md\":\"616e02ad\",\"webpack_webpack官方文档.md\":\"18d6e311\",\"webpack_webpack源码调试.md\":\"e60709ea\",\"webpack_官方文档.md\":\"5c91ac5a\",\"webpack_流程开始.md\":\"2c3c3e42\",\"webpack_热更新实现原理.md\":\"2fd3d1b1\"}")</script>
    <script type="module" async src="/assets/app.943409a9.js"></script>
    
  </body>
</html>